"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ReactionDrawer: () => ReactionDrawer,
  SvgDrawer: () => SvgDrawer,
  apply: () => apply,
  clean: () => clean,
  parse: () => parse,
  parseReaction: () => parseReaction
});
module.exports = __toCommonJS(src_exports);

// src/ArrayHelper.ts
var ArrayHelper = class _ArrayHelper {
  /**
   * Clone an array or an object. If an object is passed, a shallow clone will be created.
   *
   * @static
   * @param {*} arr The array or object to be cloned.
   * @returns {*} A clone of the array or object.
   */
  static clone(arr) {
    const out = Array.isArray(arr) ? [] : {};
    for (const key in arr) {
      const value = arr[key];
      if (typeof value.clone === "function") {
        out[key] = value.clone();
      } else {
        out[key] = typeof value === "object" ? _ArrayHelper.clone(value) : value;
      }
    }
    return out;
  }
  /**
   * Returns a boolean indicating whether or not the two arrays contain the same elements.
   * Only supports 1d, non-nested arrays.
   *
   * @static
   * @param {Array} arrA An array.
   * @param {Array} arrB An array.
   * @returns {Boolean} A boolean indicating whether or not the two arrays contain the same elements.
   */
  static equals(arrA, arrB) {
    if (arrA.length !== arrB.length) {
      return false;
    }
    const tmpA = arrA.slice().sort();
    const tmpB = arrB.slice().sort();
    for (let i = 0; i < tmpA.length; i++) {
      if (tmpA[i] !== tmpB[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a string representation of an array. If the array contains objects with an id property, the id property is printed for each of the elements.
   *
   * @static
   * @param {Object[]} arr An array.
   * @param {*} arr[].id If the array contains an object with the property 'id', the properties value is printed. Else, the array elements value is printend.
   * @returns {String} A string representation of the array.
   */
  static print(arr) {
    if (arr.length === 0) {
      return "";
    }
    let s = "(";
    for (let i = 0; i < arr.length; i++) {
      s += arr[i].id ? arr[i].id + ", " : arr[i] + ", ";
    }
    s = s.substring(0, s.length - 2);
    return s + ")";
  }
  /**
   * Run a function for each element in the array. The element is supplied as an argument for the callback function
   *
   * @static
   * @param {Array} arr An array.
   * @param {Function} callback The callback function that is called for each element.
   */
  static each(arr, callback) {
    for (let i = 0; i < arr.length; i++) {
      callback(arr[i]);
    }
  }
  /**
   * Return the array element from an array containing objects, where a property of the object is set to a given value.
   *
   * @static
   * @param {Array} arr An array.
   * @param {(String|Number)} property A property contained within an object in the array.
   * @param {(String|Number)} value The value of the property.
   * @returns {*} The array element matching the value.
   */
  static get(arr, property, value) {
    for (let i = 0; i < arr.length; i++) {
      if (arr[i][property] === value) {
        return arr[i];
      }
    }
  }
  /**
   * Checks whether or not an array contains a given value. the options object passed as a second argument can contain three properties. value: The value to be searched for. property: The property that is to be searched for a given value. func: A function that is used as a callback to return either true or false in order to do a custom comparison.
   *
   * @static
   * @param {Array} arr An array.
   * @param {Object} options See method description.
   * @param {*} options.value The value for which to check.
   * @param {String} [options.property=undefined] The property on which to check.
   * @param {Function} [options.func=undefined] A custom property function.
   * @returns {Boolean} A boolean whether or not the array contains a value.
   */
  static contains(arr, options) {
    if (!options.property && !options.func) {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] === options.value) {
          return true;
        }
      }
    } else if (options.func) {
      for (let i = 0; i < arr.length; i++) {
        if (options.func(arr[i])) {
          return true;
        }
      }
    } else {
      for (let i = 0; i < arr.length; i++) {
        if (arr[i][options.property] === options.value) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Returns an array containing the intersection between two arrays. That is, values that are common to both arrays.
   *
   * @static
   * @param {Array} arrA An array.
   * @param {Array} arrB An array.
   * @returns {Array} The intersecting vlaues.
   */
  static intersection(arrA, arrB) {
    const intersection = [];
    for (let i = 0; i < arrA.length; i++) {
      for (let j = 0; j < arrB.length; j++) {
        if (arrA[i] === arrB[j]) {
          intersection.push(arrA[i]);
        }
      }
    }
    return intersection;
  }
  /**
   * Returns an array of unique elements contained in an array.
   *
   * @static
   * @param {Array} arr An array.
   * @returns {Array} An array of unique elements contained within the array supplied as an argument.
   */
  static unique(arr) {
    const contains = {};
    return arr.filter(function(i) {
      return contains[i] !== void 0 ? false : contains[i] = true;
    });
  }
  /**
   * Count the number of occurences of a value in an array.
   *
   * @static
   * @param {Array} arr An array.
   * @param {*} value A value to be counted.
   * @returns {Number} The number of occurences of a value in the array.
   */
  static count(arr, value) {
    let count = 0;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] === value) {
        count++;
      }
    }
    return count;
  }
  /**
   * Toggles the value of an array. If a value is not contained in an array, the array returned will contain all the values of the original array including the value. If a value is contained in an array, the array returned will contain all the values of the original array excluding the value.
   *
   * @static
   * @param {Array} arr An array.
   * @param {*} value A value to be toggled.
   * @returns {Array} The toggled array.
   */
  static toggle(arr, value) {
    const newArr = [];
    let removed = false;
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] !== value) {
        newArr.push(arr[i]);
      } else {
        removed = true;
      }
    }
    if (!removed) {
      newArr.push(value);
    }
    return newArr;
  }
  /**
   * Remove a value from an array.
   *
   * @static
   * @param {Array} arr An array.
   * @param {*} value A value to be removed.
   * @returns {Array} A new array with the element with a given value removed.
   */
  static remove(arr, value) {
    const tmp = [];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i] !== value) {
        tmp.push(arr[i]);
      }
    }
    return tmp;
  }
  /**
   * Remove a value from an array with unique values.
   *
   * @static
   * @param {Array} arr An array.
   * @param {*} value A value to be removed.
   * @returns {Array} An array with the element with a given value removed.
   */
  static removeUnique(arr, value) {
    const index = arr.indexOf(value);
    if (index > -1) {
      arr.splice(index, 1);
    }
    return arr;
  }
  /**
   * Remove all elements contained in one array from another array.
   *
   * @static
   * @param {Array} arrA The array to be filtered.
   * @param {Array} arrB The array containing elements that will be removed from the other array.
   * @returns {Array} The filtered array.
   */
  static removeAll(arrA, arrB) {
    return arrA.filter(function(item) {
      return arrB.indexOf(item) === -1;
    });
  }
  /**
   * Merges two arrays and returns the result. The first array will be appended to the second array.
   *
   * @static
   * @param {Array} arrA An array.
   * @param {Array} arrB An array.
   * @returns {Array} The merged array.
   */
  static merge(arrA, arrB) {
    const arr = new Array(arrA.length + arrB.length);
    for (let i = 0; i < arrA.length; i++) {
      arr[i] = arrA[i];
    }
    for (let i = 0; i < arrB.length; i++) {
      arr[arrA.length + i] = arrB[i];
    }
    return arr;
  }
  /**
   * Checks whether or not an array contains all the elements of another array, without regard to the order.
   *
   * @static
   * @param {Array} arrA An array.
   * @param {Array} arrB An array.
   * @returns {Boolean} A boolean indicating whether or not both array contain the same elements.
   */
  static containsAll(arrA, arrB) {
    let containing = 0;
    for (let i = 0; i < arrA.length; i++) {
      for (let j = 0; j < arrB.length; j++) {
        if (arrA[i] === arrB[j]) {
          containing++;
        }
      }
    }
    return containing === arrB.length;
  }
  /**
   * Sort an array of atomic number information. Where the number is indicated as x, x.y, x.y.z, ...
   *
   * @param {Object[]} arr An array of vertex ids with their associated atomic numbers.
   * @param {Number} arr[].vertexId A vertex id.
   * @param {String} arr[].atomicNumber The atomic number associated with the vertex id.
   * @returns {Object[]} The array sorted by atomic number. Example of an array entry: { atomicNumber: 2, vertexId: 5 }.
   */
  static sortByAtomicNumberDesc(arr) {
    const map = arr.map(function(e, i) {
      return { index: i, value: e.atomicNumber.split(".").map(Number) };
    });
    map.sort(function(a, b) {
      const min = Math.min(b.value.length, a.value.length);
      let i = 0;
      while (i < min && b.value[i] === a.value[i]) {
        i++;
      }
      return i === min ? b.value.length - a.value.length : b.value[i] - a.value[i];
    });
    return map.map(function(e) {
      return arr[e.index];
    });
  }
  /**
   * Copies a an n-dimensional array.
   *
   * @param {Array} arr The array to be copied.
   * @returns {Array} The copy.
   */
  static deepCopy(arr) {
    const newArr = [];
    for (let i = 0; i < arr.length; i++) {
      const item = arr[i];
      if (item instanceof Array) {
        newArr[i] = _ArrayHelper.deepCopy(item);
      } else {
        newArr[i] = item;
      }
    }
    return newArr;
  }
};

// src/Atom.ts
var Atom = class _Atom {
  element;
  drawExplicit;
  ringbonds;
  rings;
  bondType;
  branchBond;
  isBridge;
  isBridgeNode;
  originalRings;
  bridgedRing;
  anchoredRings;
  bracket;
  plane;
  attachedPseudoElements;
  hasAttachedPseudoElements;
  isDrawn;
  isConnectedToRing;
  neighbouringElements;
  isPartOfAromaticRing;
  bondCount;
  chirality;
  isStereoCenter;
  priority;
  mainChain;
  hydrogenDirection;
  subtreeDepth;
  hasHydrogen;
  class;
  /**
   * The constructor of the class Atom.
   *
   * @param {String} element The one-letter code of the element.
   * @param {String} [bondType='-'] The type of the bond associated with this atom.
   */
  constructor(element, bondType = "-") {
    this.element = element.length === 1 ? element.toUpperCase() : element;
    this.drawExplicit = false;
    this.ringbonds = [];
    this.rings = [];
    this.bondType = bondType;
    this.branchBond = null;
    this.isBridge = false;
    this.isBridgeNode = false;
    this.originalRings = [];
    this.bridgedRing = null;
    this.anchoredRings = [];
    this.bracket = null;
    this.plane = 0;
    this.attachedPseudoElements = {};
    this.hasAttachedPseudoElements = false;
    this.isDrawn = true;
    this.isConnectedToRing = false;
    this.neighbouringElements = [];
    this.isPartOfAromaticRing = element !== this.element;
    this.bondCount = 0;
    this.chirality = "";
    this.isStereoCenter = false;
    this.priority = 0;
    this.mainChain = false;
    this.hydrogenDirection = "down";
    this.subtreeDepth = 1;
    this.hasHydrogen = false;
    this.class = void 0;
  }
  /**
   * Adds a neighbouring element to this atom.
   *
   * @param {String} element A string representing an element.
   */
  addNeighbouringElement(element) {
    this.neighbouringElements.push(element);
  }
  /**
   * Attaches a pseudo element (e.g. Ac) to the atom.
   * @param {String} element The element identifier (e.g. Br, C, ...).
   * @param {String} previousElement The element that is part of the main chain (not the terminals that are converted to the pseudo element or concatinated).
   * @param {Number} [hydrogenCount=0] The number of hydrogens for the element.
   * @param {Number} [charge=0] The charge for the element.
   */
  attachPseudoElement(element, previousElement, hydrogenCount = 0, charge = 0) {
    if (hydrogenCount === null) {
      hydrogenCount = 0;
    }
    if (charge === null) {
      charge = 0;
    }
    const key = hydrogenCount + element + charge;
    if (this.attachedPseudoElements[key]) {
      this.attachedPseudoElements[key].count += 1;
    } else {
      this.attachedPseudoElements[key] = {
        element,
        count: 1,
        hydrogenCount,
        previousElement,
        charge
      };
    }
    this.hasAttachedPseudoElements = true;
  }
  /**
   * Returns the attached pseudo elements sorted by hydrogen count (ascending).
   *
   * @returns {Object} The sorted attached pseudo elements.
   */
  getAttachedPseudoElements() {
    const ordered = {};
    const that = this;
    Object.keys(this.attachedPseudoElements).sort().forEach(function(key) {
      ordered[key] = that.attachedPseudoElements[key];
    });
    return ordered;
  }
  /**
   * Returns the number of attached pseudo elements.
   *
   * @returns {Number} The number of attached pseudo elements.
   */
  getAttachedPseudoElementsCount() {
    return Object.keys(this.attachedPseudoElements).length;
  }
  /**
   * Returns whether this atom is a heteroatom (not C and not H).
   *
   * @returns {Boolean} A boolean indicating whether this atom is a heteroatom.
   */
  isHeteroAtom() {
    return this.element !== "C" && this.element !== "H";
  }
  /**
   * Defines this atom as the anchor for a ring. When doing repositionings of the vertices and the vertex associated with this atom is moved, the center of this ring is moved as well.
   *
   * @param {Number} ringId A ring id.
   */
  addAnchoredRing(ringId) {
    if (!ArrayHelper.contains(this.anchoredRings, {
      value: ringId
    })) {
      this.anchoredRings.push(ringId);
    }
  }
  /**
   * Returns the number of ringbonds (breaks in rings to generate the MST of the smiles) within this atom is connected to.
   *
   * @returns {Number} The number of ringbonds this atom is connected to.
   */
  getRingbondCount() {
    return this.ringbonds.length;
  }
  /**
   * Backs up the current rings.
   */
  backupRings() {
    this.originalRings = Array(this.rings.length);
    for (let i = 0; i < this.rings.length; i++) {
      this.originalRings[i] = this.rings[i];
    }
  }
  /**
   * Restores the most recent backed up rings.
   */
  restoreRings() {
    this.rings = Array(this.originalRings.length);
    for (let i = 0; i < this.originalRings.length; i++) {
      this.rings[i] = this.originalRings[i];
    }
  }
  /**
   * Checks whether or not two atoms share a common ringbond id. A ringbond is a break in a ring created when generating the spanning tree of a structure.
   *
   * @param {Atom} atomA An atom.
   * @param {Atom} atomB An atom.
   * @returns {Boolean} A boolean indicating whether or not two atoms share a common ringbond.
   */
  haveCommonRingbond(atomA, atomB) {
    for (let i = 0; i < atomA.ringbonds.length; i++) {
      for (let j = 0; j < atomB.ringbonds.length; j++) {
        if (atomA.ringbonds[i].id === atomB.ringbonds[j].id) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Check whether or not the neighbouring elements of this atom equal the supplied array.
   *
   * @param {String[]} arr An array containing all the elements that are neighbouring this atom. E.g. ['C', 'O', 'O', 'N']
   * @returns {Boolean} A boolean indicating whether or not the neighbours match the supplied array of elements.
   */
  neighbouringElementsEqual(arr) {
    if (arr.length !== this.neighbouringElements.length) {
      return false;
    }
    arr.sort();
    this.neighbouringElements.sort();
    for (let i = 0; i < this.neighbouringElements.length; i++) {
      if (arr[i] !== this.neighbouringElements[i]) {
        return false;
      }
    }
    return true;
  }
  /**
   * Get the atomic number of this atom.
   *
   * @returns {Number} The atomic number of this atom.
   */
  getAtomicNumber() {
    return _Atom.atomicNumbers[this.element];
  }
  /**
   * Get the maximum number of bonds for this atom.
   *
   * @returns {Number} The maximum number of bonds of this atom.
   */
  getMaxBonds() {
    return _Atom.maxBonds[this.element];
  }
  /**
   * A map mapping element symbols to their maximum bonds.
   */
  static get maxBonds() {
    return {
      H: 1,
      C: 4,
      N: 3,
      O: 2,
      P: 3,
      S: 2,
      B: 3,
      F: 1,
      I: 1,
      Cl: 1,
      Br: 1
    };
  }
  /**
   * A map mapping element symbols to the atomic number.
   */
  static get atomicNumbers() {
    return {
      H: 1,
      He: 2,
      Li: 3,
      Be: 4,
      B: 5,
      b: 5,
      C: 6,
      c: 6,
      N: 7,
      n: 7,
      O: 8,
      o: 8,
      F: 9,
      Ne: 10,
      Na: 11,
      Mg: 12,
      Al: 13,
      Si: 14,
      P: 15,
      p: 15,
      S: 16,
      s: 16,
      Cl: 17,
      Ar: 18,
      K: 19,
      Ca: 20,
      Sc: 21,
      Ti: 22,
      V: 23,
      Cr: 24,
      Mn: 25,
      Fe: 26,
      Co: 27,
      Ni: 28,
      Cu: 29,
      Zn: 30,
      Ga: 31,
      Ge: 32,
      As: 33,
      Se: 34,
      Br: 35,
      Kr: 36,
      Rb: 37,
      Sr: 38,
      Y: 39,
      Zr: 40,
      Nb: 41,
      Mo: 42,
      Tc: 43,
      Ru: 44,
      Rh: 45,
      Pd: 46,
      Ag: 47,
      Cd: 48,
      In: 49,
      Sn: 50,
      Sb: 51,
      Te: 52,
      I: 53,
      Xe: 54,
      Cs: 55,
      Ba: 56,
      La: 57,
      Ce: 58,
      Pr: 59,
      Nd: 60,
      Pm: 61,
      Sm: 62,
      Eu: 63,
      Gd: 64,
      Tb: 65,
      Dy: 66,
      Ho: 67,
      Er: 68,
      Tm: 69,
      Yb: 70,
      Lu: 71,
      Hf: 72,
      Ta: 73,
      W: 74,
      Re: 75,
      Os: 76,
      Ir: 77,
      Pt: 78,
      Au: 79,
      Hg: 80,
      Tl: 81,
      Pb: 82,
      Bi: 83,
      Po: 84,
      At: 85,
      Rn: 86,
      Fr: 87,
      Ra: 88,
      Ac: 89,
      Th: 90,
      Pa: 91,
      U: 92,
      Np: 93,
      Pu: 94,
      Am: 95,
      Cm: 96,
      Bk: 97,
      Cf: 98,
      Es: 99,
      Fm: 100,
      Md: 101,
      No: 102,
      Lr: 103,
      Rf: 104,
      Db: 105,
      Sg: 106,
      Bh: 107,
      Hs: 108,
      Mt: 109,
      Ds: 110,
      Rg: 111,
      Cn: 112,
      Uut: 113,
      Uuq: 114,
      Uup: 115,
      Uuh: 116,
      Uus: 117,
      Uuo: 118
    };
  }
  /**
   * A map mapping element symbols to the atomic mass.
   */
  static get mass() {
    return {
      H: 1,
      He: 2,
      Li: 3,
      Be: 4,
      B: 5,
      b: 5,
      C: 6,
      c: 6,
      N: 7,
      n: 7,
      O: 8,
      o: 8,
      F: 9,
      Ne: 10,
      Na: 11,
      Mg: 12,
      Al: 13,
      Si: 14,
      P: 15,
      p: 15,
      S: 16,
      s: 16,
      Cl: 17,
      Ar: 18,
      K: 19,
      Ca: 20,
      Sc: 21,
      Ti: 22,
      V: 23,
      Cr: 24,
      Mn: 25,
      Fe: 26,
      Co: 27,
      Ni: 28,
      Cu: 29,
      Zn: 30,
      Ga: 31,
      Ge: 32,
      As: 33,
      Se: 34,
      Br: 35,
      Kr: 36,
      Rb: 37,
      Sr: 38,
      Y: 39,
      Zr: 40,
      Nb: 41,
      Mo: 42,
      Tc: 43,
      Ru: 44,
      Rh: 45,
      Pd: 46,
      Ag: 47,
      Cd: 48,
      In: 49,
      Sn: 50,
      Sb: 51,
      Te: 52,
      I: 53,
      Xe: 54,
      Cs: 55,
      Ba: 56,
      La: 57,
      Ce: 58,
      Pr: 59,
      Nd: 60,
      Pm: 61,
      Sm: 62,
      Eu: 63,
      Gd: 64,
      Tb: 65,
      Dy: 66,
      Ho: 67,
      Er: 68,
      Tm: 69,
      Yb: 70,
      Lu: 71,
      Hf: 72,
      Ta: 73,
      W: 74,
      Re: 75,
      Os: 76,
      Ir: 77,
      Pt: 78,
      Au: 79,
      Hg: 80,
      Tl: 81,
      Pb: 82,
      Bi: 83,
      Po: 84,
      At: 85,
      Rn: 86,
      Fr: 87,
      Ra: 88,
      Ac: 89,
      Th: 90,
      Pa: 91,
      U: 92,
      Np: 93,
      Pu: 94,
      Am: 95,
      Cm: 96,
      Bk: 97,
      Cf: 98,
      Es: 99,
      Fm: 100,
      Md: 101,
      No: 102,
      Lr: 103,
      Rf: 104,
      Db: 105,
      Sg: 106,
      Bh: 107,
      Hs: 108,
      Mt: 109,
      Ds: 110,
      Rg: 111,
      Cn: 112,
      Uut: 113,
      Uuq: 114,
      Uup: 115,
      Uuh: 116,
      Uus: 117,
      Uuo: 118
    };
  }
};

// src/MathHelper.ts
var MathHelper = class _MathHelper {
  /**
   * Rounds a value to a given number of decimals.
   *
   * @static
   * @param {Number} value A number.
   * @param {Number} decimals The number of decimals.
   * @returns {Number} A number rounded to a given number of decimals.
   */
  static round(value, decimals) {
    decimals = decimals ? decimals : 1;
    return Number(Math.round(Number(value + "e" + decimals)) + "e-" + decimals);
  }
  /**
   * Returns the means of the angles contained in an array. In radians.
   *
   * @static
   * @param {Number[]} arr An array containing angles (in radians).
   * @returns {Number} The mean angle in radians.
   */
  static meanAngle(arr) {
    let sin = 0;
    let cos = 0;
    for (let i = 0; i < arr.length; i++) {
      sin += Math.sin(arr[i]);
      cos += Math.cos(arr[i]);
    }
    return Math.atan2(sin / arr.length, cos / arr.length);
  }
  /**
   * Returns the inner angle of a n-sided regular polygon.
   *
   * @static
   * @param {Number} n Number of sides of a regular polygon.
   * @returns {Number} The inner angle of a given regular polygon.
   */
  static innerAngle(n) {
    return _MathHelper.toRad((n - 2) * 180 / n);
  }
  /**
   * Returns the circumradius of a n-sided regular polygon with a given side-length.
   *
   * @static
   * @param {Number} s The side length of the regular polygon.
   * @param {Number} n The number of sides.
   * @returns {Number} The circumradius of the regular polygon.
   */
  static polyCircumradius(s, n) {
    return s / (2 * Math.sin(Math.PI / n));
  }
  /**
   * Returns the apothem of a regular n-sided polygon based on its radius.
   *
   * @static
   * @param {Number} r The radius.
   * @param {Number} n The number of edges of the regular polygon.
   * @returns {Number} The apothem of a n-sided polygon based on its radius.
   */
  static apothem(r, n) {
    return r * Math.cos(Math.PI / n);
  }
  static apothemFromSideLength(s, n) {
    const r = _MathHelper.polyCircumradius(s, n);
    return _MathHelper.apothem(r, n);
  }
  /**
   * The central angle of a n-sided regular polygon. In radians.
   *
   * @static
   * @param {Number} n The number of sides of the regular polygon.
   * @returns {Number} The central angle of the n-sided polygon in radians.
   */
  static centralAngle(n) {
    return _MathHelper.toRad(360 / n);
  }
  /**
   * Convertes radians to degrees.
   *
   * @static
   * @param {Number} rad An angle in radians.
   * @returns {Number} The angle in degrees.
   */
  static toDeg(rad) {
    return rad * _MathHelper.degFactor;
  }
  /**
   * Converts degrees to radians.
   *
   * @static
   * @param {Number} deg An angle in degrees.
   * @returns {Number} The angle in radians.
   */
  static toRad(deg) {
    return deg * _MathHelper.radFactor;
  }
  /**
   * Returns the parity of the permutation (1 or -1)
   * @param {(Array|Uint8Array)} arr An array containing the permutation.
   * @returns {Number} The parity of the permutation (1 or -1), where 1 means even and -1 means odd.
   */
  static parityOfPermutation(arr) {
    const visited = new Uint8Array(arr.length);
    let evenLengthCycleCount = 0;
    const traverseCycle = function(i, cycleLength = 0) {
      if (visited[i] === 1) {
        return cycleLength;
      }
      cycleLength++;
      visited[i] = 1;
      return traverseCycle(arr[i], cycleLength);
    };
    for (let i = 0; i < arr.length; i++) {
      if (visited[i] === 1) {
        continue;
      }
      const cycleLength = traverseCycle(i);
      evenLengthCycleCount += 1 - cycleLength % 2;
    }
    return evenLengthCycleCount % 2 ? -1 : 1;
  }
  /** The factor to convert degrees to radians. */
  static get radFactor() {
    return Math.PI / 180;
  }
  /** The factor to convert radians to degrees. */
  static get degFactor() {
    return 180 / Math.PI;
  }
  /** Two times PI. */
  static get twoPI() {
    return 2 * Math.PI;
  }
};

// src/Vector2.ts
var Vector2 = class _Vector2 {
  x;
  y;
  /**
   * The constructor of the class Vector2.
   *
   * @param {(Number|Vector2)} x The initial x coordinate value or, if the single argument, a Vector2 object.
   * @param {Number} y The initial y coordinate value.
   */
  constructor(x, y) {
    if (arguments.length === 0) {
      this.x = 0;
      this.y = 0;
    } else if (arguments.length === 1) {
      this.x = x.x;
      this.y = x.y;
    } else {
      this.x = x;
      this.y = y;
    }
  }
  /**
   * Clones this vector and returns the clone.
   *
   * @returns {Vector2} The clone of this vector.
   */
  clone() {
    return new _Vector2(this.x, this.y);
  }
  /**
   * Returns a string representation of this vector.
   *
   * @returns {String} A string representation of this vector.
   */
  toString() {
    return "(" + this.x + "," + this.y + ")";
  }
  /**
   * Add the x and y coordinate values of a vector to the x and y coordinate values of this vector.
   *
   * @param {Vector2} vec Another vector.
   * @returns {Vector2} Returns itself.
   */
  add(vec) {
    this.x += vec.x;
    this.y += vec.y;
    return this;
  }
  /**
   * Subtract the x and y coordinate values of a vector from the x and y coordinate values of this vector.
   *
   * @param {Vector2} vec Another vector.
   * @returns {Vector2} Returns itself.
   */
  subtract(vec) {
    this.x -= vec.x;
    this.y -= vec.y;
    return this;
  }
  /**
   * Divide the x and y coordinate values of this vector by a scalar.
   *
   * @param {Number} scalar The scalar.
   * @returns {Vector2} Returns itself.
   */
  divide(scalar) {
    this.x /= scalar;
    this.y /= scalar;
    return this;
  }
  /**
   * Multiply the x and y coordinate values of this vector by the values of another vector.
   *
   * @param {Vector2} v A vector.
   * @returns {Vector2} Returns itself.
   */
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  /**
   * Multiply the x and y coordinate values of this vector by a scalar.
   *
   * @param {Number} scalar The scalar.
   * @returns {Vector2} Returns itself.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  /**
   * Inverts this vector. Same as multiply(-1.0).
   *
   * @returns {Vector2} Returns itself.
   */
  invert() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  /**
   * Returns the angle of this vector in relation to the coordinate system.
   *
   * @returns {Number} The angle in radians.
   */
  angle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns the euclidean distance between this vector and another vector.
   *
   * @param {Vector2} vec A vector.
   * @returns {Number} The euclidean distance between the two vectors.
   */
  distance(vec) {
    return Math.sqrt(
      (vec.x - this.x) * (vec.x - this.x) + (vec.y - this.y) * (vec.y - this.y)
    );
  }
  /**
   * Returns the squared euclidean distance between this vector and another vector. When only the relative distances of a set of vectors are needed, this is is less expensive than using distance(vec).
   *
   * @param {Vector2} vec Another vector.
   * @returns {Number} The squared euclidean distance of the two vectors.
   */
  distanceSq(vec) {
    return (vec.x - this.x) * (vec.x - this.x) + (vec.y - this.y) * (vec.y - this.y);
  }
  /**
   * Checks whether or not this vector is in a clockwise or counter-clockwise rotational direction compared to another vector in relation to the coordinate system.
   *
   * @param {Vector2} vec Another vector.
   * @returns {Number} Returns -1, 0 or 1 if the vector supplied as an argument is clockwise, neutral or counter-clockwise respectively to this vector in relation to the coordinate system.
   */
  clockwise(vec) {
    const a = this.y * vec.x;
    const b = this.x * vec.y;
    if (a > b) {
      return -1;
    } else if (a === b) {
      return 0;
    }
    return 1;
  }
  /**
   * Checks whether or not this vector is in a clockwise or counter-clockwise rotational direction compared to another vector in relation to an arbitrary third vector.
   *
   * @param {Vector2} center The central vector.
   * @param {Vector2} vec Another vector.
   * @returns {Number} Returns -1, 0 or 1 if the vector supplied as an argument is clockwise, neutral or counter-clockwise respectively to this vector in relation to an arbitrary third vector.
   */
  relativeClockwise(center, vec) {
    const a = (this.y - center.y) * (vec.x - center.x);
    const b = (this.x - center.x) * (vec.y - center.y);
    if (a > b) {
      return -1;
    } else if (a === b) {
      return 0;
    }
    return 1;
  }
  /**
   * Rotates this vector by a given number of radians around the origin of the coordinate system.
   *
   * @param {Number} angle The angle in radians to rotate the vector.
   * @returns {Vector2} Returns itself.
   */
  rotate(angle) {
    const tmp = new _Vector2(0, 0);
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    tmp.x = this.x * cosAngle - this.y * sinAngle;
    tmp.y = this.x * sinAngle + this.y * cosAngle;
    this.x = tmp.x;
    this.y = tmp.y;
    return this;
  }
  /**
   * Rotates this vector around another vector.
   *
   * @param {Number} angle The angle in radians to rotate the vector.
   * @param {Vector2} vec The vector which is used as the rotational center.
   * @returns {Vector2} Returns itself.
   */
  rotateAround(angle, vec) {
    const s = Math.sin(angle);
    const c = Math.cos(angle);
    this.x -= vec.x;
    this.y -= vec.y;
    const x = this.x * c - this.y * s;
    const y = this.x * s + this.y * c;
    this.x = x + vec.x;
    this.y = y + vec.y;
    return this;
  }
  /**
   * Rotate a vector around a given center to the same angle as another vector (so that the two vectors and the center are in a line, with both vectors on one side of the center), keeps the distance from this vector to the center.
   *
   * @param {Vector2} vec The vector to rotate this vector to.
   * @param {Vector2} center The rotational center.
   * @param {Number} [offsetAngle=0.0] An additional amount of radians to rotate the vector.
   * @returns {Vector2} Returns itself.
   */
  rotateTo(vec, center, offsetAngle = 0) {
    this.x += 1e-3;
    this.y -= 1e-3;
    const a = _Vector2.subtract(this, center);
    const b = _Vector2.subtract(vec, center);
    const angle = _Vector2.angle(b, a);
    this.rotateAround(angle + offsetAngle, center);
    return this;
  }
  /**
   * Rotates the vector away from a specified vector around a center.
   *
   * @param {Vector2} vec The vector this one is rotated away from.
   * @param {Vector2} center The rotational center.
   * @param {Number} angle The angle by which to rotate.
   */
  rotateAwayFrom(vec, center, angle) {
    this.rotateAround(angle, center);
    const distSqA = this.distanceSq(vec);
    this.rotateAround(-2 * angle, center);
    const distSqB = this.distanceSq(vec);
    if (distSqB < distSqA) {
      this.rotateAround(2 * angle, center);
    }
  }
  /**
   * Returns the angle in radians used to rotate this vector away from a given vector.
   *
   * @param {Vector2} vec The vector this one is rotated away from.
   * @param {Vector2} center The rotational center.
   * @param {Number} angle The angle by which to rotate.
   * @returns {Number} The angle in radians.
   */
  getRotateAwayFromAngle(vec, center, angle) {
    const tmp = this.clone();
    tmp.rotateAround(angle, center);
    const distSqA = tmp.distanceSq(vec);
    tmp.rotateAround(-2 * angle, center);
    const distSqB = tmp.distanceSq(vec);
    if (distSqB < distSqA) {
      return angle;
    } else {
      return -angle;
    }
  }
  /**
   * Returns the angle in radians used to rotate this vector towards a given vector.
   *
   * @param {Vector2} vec The vector this one is rotated towards to.
   * @param {Vector2} center The rotational center.
   * @param {Number} angle The angle by which to rotate.
   * @returns {Number} The angle in radians.
   */
  getRotateTowardsAngle(vec, center, angle) {
    const tmp = this.clone();
    tmp.rotateAround(angle, center);
    const distSqA = tmp.distanceSq(vec);
    tmp.rotateAround(-2 * angle, center);
    const distSqB = tmp.distanceSq(vec);
    if (distSqB > distSqA) {
      return angle;
    } else {
      return -angle;
    }
  }
  /**
   * Gets the angles between this vector and another vector around a common center of rotation.
   *
   * @param {Vector2} vec Another vector.
   * @param {Vector2} center The center of rotation.
   * @returns {Number} The angle between this vector and another vector around a center of rotation in radians.
   */
  getRotateToAngle(vec, center) {
    const a = _Vector2.subtract(this, center);
    const b = _Vector2.subtract(vec, center);
    const angle = _Vector2.angle(b, a);
    return Number.isNaN(angle) ? 0 : angle;
  }
  /**
   * Checks whether a vector lies within a polygon spanned by a set of vectors.
   *
   * @param {Vector2[]} polygon An array of vectors spanning the polygon.
   * @returns {Boolean} A boolean indicating whether or not this vector is within a polygon.
   */
  isInPolygon(polygon) {
    let inside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      if (polygon[i].y > this.y !== polygon[j].y > this.y && this.x < (polygon[j].x - polygon[i].x) * (this.y - polygon[i].y) / (polygon[j].y - polygon[i].y) + polygon[i].x) {
        inside = !inside;
      }
    }
    return inside;
  }
  /**
   * Returns the length of this vector.
   *
   * @returns {Number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Returns the square of the length of this vector.
   *
   * @returns {Number} The square of the length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Normalizes this vector.
   *
   * @returns {Vector2} Returns itself.
   */
  normalize() {
    this.divide(this.length());
    return this;
  }
  /**
   * Returns a normalized copy of this vector.
   *
   * @returns {Vector2} A normalized copy of this vector.
   */
  normalized() {
    return _Vector2.divideScalar(this, this.length());
  }
  /**
   * Calculates which side of a line spanned by two vectors this vector is.
   *
   * @param {Vector2} vecA A vector.
   * @param {Vector2} vecB A vector.
   * @returns {Number} A number indicating the side of this vector, given a line spanned by two other vectors.
   */
  whichSide(vecA, vecB) {
    return (this.x - vecA.x) * (vecB.y - vecA.y) - (this.y - vecA.y) * (vecB.x - vecA.x);
  }
  /**
   * Checks whether or not this vector is on the same side of a line spanned by two vectors as another vector.
   *
   * @param {Vector2} vecA A vector spanning the line.
   * @param {Vector2} vecB A vector spanning the line.
   * @param {Vector2} vecC A vector to check whether or not it is on the same side as this vector.
   * @returns {Boolean} Returns a boolean indicating whether or not this vector is on the same side as another vector.
   */
  sameSideAs(vecA, vecB, vecC) {
    const d = this.whichSide(vecA, vecB);
    const dRef = vecC.whichSide(vecA, vecB);
    return d < 0 && dRef < 0 || d === 0 && dRef === 0 || d > 0 && dRef > 0;
  }
  /**
   * Adds two vectors and returns the result as a new vector.
   *
   * @static
   * @param {Vector2} vecA A summand.
   * @param {Vector2} vecB A summand.
   * @returns {Vector2} Returns the sum of two vectors.
   */
  static add(vecA, vecB) {
    return new _Vector2(vecA.x + vecB.x, vecA.y + vecB.y);
  }
  /**
   * Subtracts one vector from another and returns the result as a new vector.
   *
   * @static
   * @param {Vector2} vecA The minuend.
   * @param {Vector2} vecB The subtrahend.
   * @returns {Vector2} Returns the difference of two vectors.
   */
  static subtract(vecA, vecB) {
    return new _Vector2(vecA.x - vecB.x, vecA.y - vecB.y);
  }
  /**
   * Multiplies two vectors (value by value) and returns the result.
   *
   * @static
   * @param {Vector2} vecA A vector.
   * @param {Vector2} vecB A vector.
   * @returns {Vector2} Returns the product of two vectors.
   */
  static multiply(vecA, vecB) {
    return new _Vector2(vecA.x * vecB.x, vecA.y * vecB.y);
  }
  /**
   * Multiplies two vectors (value by value) and returns the result.
   *
   * @static
   * @param {Vector2} vec A vector.
   * @param {Number} scalar A scalar.
   * @returns {Vector2} Returns the product of two vectors.
   */
  static multiplyScalar(vec, scalar) {
    return new _Vector2(vec.x, vec.y).multiplyScalar(scalar);
  }
  /**
   * Returns the midpoint of a line spanned by two vectors.
   *
   * @static
   * @param {Vector2} vecA A vector spanning the line.
   * @param {Vector2} vecB A vector spanning the line.
   * @returns {Vector2} The midpoint of the line spanned by two vectors.
   */
  static midpoint(vecA, vecB) {
    return new _Vector2((vecA.x + vecB.x) / 2, (vecA.y + vecB.y) / 2);
  }
  /**
   * Returns the normals of a line spanned by two vectors.
   *
   * @static
   * @param {Vector2} vecA A vector spanning the line.
   * @param {Vector2} vecB A vector spanning the line.
   * @returns {Vector2[]} An array containing the two normals, each represented by a vector.
   */
  static normals(vecA, vecB) {
    const delta = _Vector2.subtract(vecB, vecA);
    return [new _Vector2(-delta.y, delta.x), new _Vector2(delta.y, -delta.x)];
  }
  /**
   * Returns the unit (normalized normal) vectors of a line spanned by two vectors.
   *
   * @static
   * @param {Vector2} vecA A vector spanning the line.
   * @param {Vector2} vecB A vector spanning the line.
   * @returns {Vector2[]} An array containing the two unit vectors.
   */
  static units(vecA, vecB) {
    const delta = _Vector2.subtract(vecB, vecA);
    return [
      new _Vector2(-delta.y, delta.x).normalize(),
      new _Vector2(delta.y, -delta.x).normalize()
    ];
  }
  /**
   * Divides a vector by another vector and returns the result as new vector.
   *
   * @static
   * @param {Vector2} vecA The dividend.
   * @param {Vector2} vecB The divisor.
   * @returns {Vector2} The fraction of the two vectors.
   */
  static divide(vecA, vecB) {
    return new _Vector2(vecA.x / vecB.x, vecA.y / vecB.y);
  }
  /**
   * Divides a vector by a scalar and returns the result as new vector.
   *
   * @static
   * @param {Vector2} vecA The dividend.
   * @param {Number} s The scalar.
   * @returns {Vector2} The fraction of the two vectors.
   */
  static divideScalar(vecA, s) {
    return new _Vector2(vecA.x / s, vecA.y / s);
  }
  /**
   * Returns the dot product of two vectors.
   *
   * @static
   * @param {Vector2} vecA A vector.
   * @param {Vector2} vecB A vector.
   * @returns {Number} The dot product of two vectors.
   */
  static dot(vecA, vecB) {
    return vecA.x * vecB.x + vecA.y * vecB.y;
  }
  /**
   * Returns the angle between two vectors.
   *
   * @static
   * @param {Vector2} vecA A vector.
   * @param {Vector2} vecB A vector.
   * @returns {Number} The angle between two vectors in radians.
   */
  static angle(vecA, vecB) {
    const dot = _Vector2.dot(vecA, vecB);
    return Math.acos(dot / (vecA.length() * vecB.length()));
  }
  /**
   * Returns the angle between two vectors based on a third vector in between.
   *
   * @static
   * @param {Vector2} vecA A vector.
   * @param {Vector2} vecB A (central) vector.
   * @param {Vector2} vecC A vector.
   * @returns {Number} The angle in radians.
   */
  static threePointangle(vecA, vecB, vecC) {
    const ab = _Vector2.subtract(vecB, vecA);
    const bc = _Vector2.subtract(vecC, vecB);
    const abLength = vecA.distance(vecB);
    const bcLength = vecB.distance(vecC);
    return Math.acos(_Vector2.dot(ab, bc) / (abLength * bcLength));
  }
  /**
   * Returns the scalar projection of a vector on another vector.
   *
   * @static
   * @param {Vector2} vecA The vector to be projected.
   * @param {Vector2} vecB The vector to be projection upon.
   * @returns {Number} The scalar component.
   */
  static scalarProjection(vecA, vecB) {
    const unit = vecB.normalized();
    return _Vector2.dot(vecA, unit);
  }
  /**
   * Returns the average vector (normalized) of the input vectors.
   *
   * @static
   * @param {Array} vecs An array containing vectors.
   * @returns {Vector2} The resulting vector (normalized).
   */
  static averageDirection(vecs) {
    const avg = new _Vector2(0, 0);
    for (let i = 0; i < vecs.length; i++) {
      const vec = vecs[i];
      avg.add(vec);
    }
    return avg.normalize();
  }
};

// src/Line.ts
var Line = class _Line {
  from;
  to;
  elementFrom;
  elementTo;
  chiralFrom;
  chiralTo;
  /**
   * The constructor for the class Line.
   *
   * @param {Vector2} [from=new Vector2(0, 0)] A vector marking the beginning of the line.
   * @param {Vector2} [to=new Vector2(0, 0)] A vector marking the end of the line.
   * @param {string} [elementFrom=null] A one-letter representation of the element associated with the vector marking the beginning of the line.
   * @param {string} [elementTo=null] A one-letter representation of the element associated with the vector marking the end of the line.
   * @param {Boolean} [chiralFrom=false] Whether or not the from atom is a chiral center.
   * @param {Boolean} [chiralTo=false] Whether or not the to atom is a chiral center.
   */
  constructor(from = new Vector2(0, 0), to = new Vector2(0, 0), elementFrom = null, elementTo = null, chiralFrom = false, chiralTo = false) {
    this.from = from;
    this.to = to;
    this.elementFrom = elementFrom;
    this.elementTo = elementTo;
    this.chiralFrom = chiralFrom;
    this.chiralTo = chiralTo;
  }
  /**
   * Clones this line and returns the clone.
   *
   * @returns {Line} A clone of this line.
   */
  clone() {
    return new _Line(
      this.from.clone(),
      this.to.clone(),
      this.elementFrom,
      this.elementTo
    );
  }
  /**
   * Returns the length of this line.
   *
   * @returns {Number} The length of this line.
   */
  getLength() {
    return Math.sqrt(
      Math.pow(this.to.x - this.from.x, 2) + Math.pow(this.to.y - this.from.y, 2)
    );
  }
  /**
   * Returns the angle of the line in relation to the coordinate system (the x-axis).
   *
   * @returns {Number} The angle in radians.
   */
  getAngle() {
    const diff = Vector2.subtract(this.getRightVector(), this.getLeftVector());
    return diff.angle();
  }
  /**
   * Returns the right vector (the vector with the larger x value).
   *
   * @returns {Vector2} The right vector.
   */
  getRightVector() {
    if (this.from.x < this.to.x) {
      return this.to;
    } else {
      return this.from;
    }
  }
  /**
   * Returns the left vector (the vector with the smaller x value).
   *
   * @returns {Vector2} The left vector.
   */
  getLeftVector() {
    if (this.from.x < this.to.x) {
      return this.from;
    } else {
      return this.to;
    }
  }
  /**
   * Returns the element associated with the right vector (the vector with the larger x value).
   *
   * @returns {String} The element associated with the right vector.
   */
  getRightElement() {
    if (this.from.x < this.to.x) {
      return this.elementTo;
    } else {
      return this.elementFrom;
    }
  }
  /**
   * Returns the element associated with the left vector (the vector with the smaller x value).
   *
   * @returns {String} The element associated with the left vector.
   */
  getLeftElement() {
    if (this.from.x < this.to.x) {
      return this.elementFrom;
    } else {
      return this.elementTo;
    }
  }
  /**
   * Returns whether or not the atom associated with the right vector (the vector with the larger x value) is a chiral center.
   *
   * @returns {Boolean} Whether or not the atom associated with the right vector is a chiral center.
   */
  getRightChiral() {
    if (this.from.x < this.to.x) {
      return this.chiralTo;
    } else {
      return this.chiralFrom;
    }
  }
  /**
   * Returns whether or not the atom associated with the left vector (the vector with the smaller x value) is a chiral center.
   *
   * @returns {Boolean} Whether or not the atom  associated with the left vector is a chiral center.
   */
  getLeftChiral() {
    if (this.from.x < this.to.x) {
      return this.chiralFrom;
    } else {
      return this.chiralTo;
    }
  }
  /**
   * Set the value of the right vector.
   *
   * @param {Number} x The x value.
   * @param {Number} y The y value.
   * @returns {Line} This line.
   */
  setRightVector(x, y) {
    if (this.from.x < this.to.x) {
      this.to.x = x;
      this.to.y = y;
    } else {
      this.from.x = x;
      this.from.y = y;
    }
    return this;
  }
  /**
   * Set the value of the left vector.
   *
   * @param {Number} x The x value.
   * @param {Number} y The y value.
   * @returns {Line} This line.
   */
  setLeftVector(x, y) {
    if (this.from.x < this.to.x) {
      this.from.x = x;
      this.from.y = y;
    } else {
      this.to.x = x;
      this.to.y = y;
    }
    return this;
  }
  /**
   * Rotates this line to be aligned with the x-axis. The center of rotation is the left vector.
   *
   * @returns {Line} This line.
   */
  rotateToXAxis() {
    const left = this.getLeftVector();
    this.setRightVector(left.x + this.getLength(), left.y);
    return this;
  }
  /**
   * Rotate the line by a given value (in radians). The center of rotation is the left vector.
   *
   * @param {Number} theta The angle (in radians) to rotate the line.
   * @returns {Line} This line.
   */
  rotate(theta) {
    const l = this.getLeftVector();
    const r = this.getRightVector();
    const sinTheta = Math.sin(theta);
    const cosTheta = Math.cos(theta);
    const x = cosTheta * (r.x - l.x) - sinTheta * (r.y - l.y) + l.x;
    const y = sinTheta * (r.x - l.x) - cosTheta * (r.y - l.y) + l.y;
    this.setRightVector(x, y);
    return this;
  }
  /**
   * Shortens this line from the "from" direction by a given value (in pixels).
   *
   * @param {Number} by The length in pixels to shorten the vector by.
   * @returns {Line} This line.
   */
  shortenFrom(by) {
    const f = Vector2.subtract(this.to, this.from);
    f.normalize();
    f.multiplyScalar(by);
    this.from.add(f);
    return this;
  }
  /**
   * Shortens this line from the "to" direction by a given value (in pixels).
   *
   * @param {Number} by The length in pixels to shorten the vector by.
   * @returns {Line} This line.
   */
  shortenTo(by) {
    const f = Vector2.subtract(this.from, this.to);
    f.normalize();
    f.multiplyScalar(by);
    this.to.add(f);
    return this;
  }
  /**
   * Shorten the right side.
   *
   * @param {Number} by The length in pixels to shorten the vector by.
   * @returns {Line} Returns itself.
   */
  shortenRight(by) {
    if (this.from.x < this.to.x) {
      this.shortenTo(by);
    } else {
      this.shortenFrom(by);
    }
    return this;
  }
  /**
   * Shorten the left side.
   *
   * @param {Number} by The length in pixels to shorten the vector by.
   * @returns {Line} Returns itself.
   */
  shortenLeft(by) {
    if (this.from.x < this.to.x) {
      this.shortenFrom(by);
    } else {
      this.shortenTo(by);
    }
    return this;
  }
  /**
   * Shortens this line from both directions by a given value (in pixels).
   *
   * @param {Number} by The length in pixels to shorten the vector by.
   * @returns {Line} This line.
   */
  shorten(by) {
    const f = Vector2.subtract(this.from, this.to);
    f.normalize();
    f.multiplyScalar(by / 2);
    this.to.add(f);
    this.from.subtract(f);
    return this;
  }
};

// src/Edge.ts
var Edge = class _Edge {
  id;
  sourceId;
  targetId;
  weight;
  bondType;
  isPartOfAromaticRing;
  center;
  wedge;
  /**
   * The constructor for the class Edge.
   *
   * @param {Number} sourceId A vertex id.
   * @param {Number} targetId A vertex id.
   * @param {Number} [weight=1] The weight of the edge.
   */
  constructor(sourceId, targetId, weight = 1) {
    this.id = null;
    this.sourceId = sourceId;
    this.targetId = targetId;
    this.weight = weight;
    this.bondType = "-";
    this.isPartOfAromaticRing = false;
    this.center = false;
    this.wedge = "";
  }
  /**
   * Set the bond type of this edge. This also sets the edge weight.
   * @param {String} bondType
   */
  setBondType(bondType) {
    this.bondType = bondType;
    this.weight = _Edge.bonds[bondType];
  }
  /**
   * An object mapping the bond type to the number of bonds.
   *
   * @returns {Object} The object containing the map.
   */
  static get bonds() {
    return {
      "-": 1,
      "/": 1,
      "\\": 1,
      "=": 2,
      "#": 3,
      $: 4
    };
  }
};

// src/RingConnection.ts
var RingConnection = class {
  id;
  firstRingId;
  secondRingId;
  vertices;
  /**
   * The constructor for the class RingConnection.
   *
   * @param {Ring} firstRing A ring.
   * @param {Ring} secondRing A ring.
   */
  constructor(firstRing, secondRing) {
    this.id = null;
    this.firstRingId = firstRing.id;
    this.secondRingId = secondRing.id;
    this.vertices = /* @__PURE__ */ new Set();
    for (let m = 0; m < firstRing.members.length; m++) {
      const c = firstRing.members[m];
      for (let n = 0; n < secondRing.members.length; n++) {
        const d = secondRing.members[n];
        if (c === d) {
          this.addVertex(c);
        }
      }
    }
  }
  /**
   * Adding a vertex to the ring connection.
   *
   * @param {Number} vertexId A vertex id.
   */
  addVertex(vertexId) {
    this.vertices.add(vertexId);
  }
  /**
   * Update the ring id of this ring connection that is not the ring id supplied as the second argument.
   *
   * @param {Number} ringId A ring id. The new ring id to be set.
   * @param {Number} otherRingId A ring id. The id that is NOT to be updated.
   */
  updateOther(ringId, otherRingId) {
    if (this.firstRingId === otherRingId) {
      this.secondRingId = ringId;
    } else {
      this.firstRingId = ringId;
    }
  }
  /**
   * Returns a boolean indicating whether or not a ring with a given id is participating in this ring connection.
   *
   * @param {Number} ringId A ring id.
   * @returns {Boolean} A boolean indicating whether or not a ring with a given id participates in this ring connection.
   */
  containsRing(ringId) {
    return this.firstRingId === ringId || this.secondRingId === ringId;
  }
  /**
   * Checks whether or not this ring connection is a bridge in a bridged ring.
   *
   * @param {Vertex[]} vertices The array of vertices associated with the current molecule.
   * @returns {Boolean} A boolean indicating whether or not this ring connection is a bridge.
   */
  isBridge(vertices) {
    if (this.vertices.size > 2) {
      return true;
    }
    for (const vertexId of this.vertices) {
      if (vertices[vertexId].value.rings.length > 2) {
        return true;
      }
    }
    return false;
  }
  /**
   * Checks whether or not two rings are connected by a bridged bond.
   *
   * @static
   * @param {RingConnection[]} ringConnections An array of ring connections containing the ring connections associated with the current molecule.
   * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.
   * @param {Number} firstRingId A ring id.
   * @param {Number} secondRingId A ring id.
   * @returns {Boolean} A boolean indicating whether or not two rings ar connected by a bridged bond.
   */
  static isBridge(ringConnections, vertices, firstRingId, secondRingId) {
    let ringConnection = null;
    for (let i = 0; i < ringConnections.length; i++) {
      ringConnection = ringConnections[i];
      if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {
        return ringConnection.isBridge(vertices);
      }
    }
    return false;
  }
  /**
   * Retruns the neighbouring rings of a given ring.
   *
   * @static
   * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.
   * @param {Number} ringId A ring id.
   * @returns {Number[]} An array of ring ids of neighbouring rings.
   */
  static getNeighbours(ringConnections, ringId) {
    const neighbours = [];
    for (let i = 0; i < ringConnections.length; i++) {
      const ringConnection = ringConnections[i];
      if (ringConnection.firstRingId === ringId) {
        neighbours.push(ringConnection.secondRingId);
      } else if (ringConnection.secondRingId === ringId) {
        neighbours.push(ringConnection.firstRingId);
      }
    }
    return neighbours;
  }
  /**
   * Returns an array of vertex ids associated with a given ring connection.
   *
   * @static
   * @param {RingConnection[]} ringConnections An array of ring connections containing ring connections associated with the current molecule.
   * @param {Number} firstRingId A ring id.
   * @param {Number} secondRingId A ring id.
   * @returns {Number[]} An array of vertex ids associated with the ring connection.
   */
  static getVertices(ringConnections, firstRingId, secondRingId) {
    for (let i = 0; i < ringConnections.length; i++) {
      const ringConnection = ringConnections[i];
      if (ringConnection.firstRingId === firstRingId && ringConnection.secondRingId === secondRingId || ringConnection.firstRingId === secondRingId && ringConnection.secondRingId === firstRingId) {
        return [...ringConnection.vertices];
      }
    }
  }
};

// src/Ring.ts
var Ring = class _Ring {
  id;
  members;
  edges;
  insiders;
  neighbours;
  positioned;
  center;
  rings;
  isBridged;
  isPartOfBridged;
  isSpiro;
  isFused;
  centralAngle;
  canFlip;
  /**
   * The constructor for the class Ring.
   *
   * @param {Number[]} members An array containing the vertex ids of the members of the ring to be created.
   */
  constructor(members) {
    this.id = null;
    this.members = members;
    this.edges = [];
    this.insiders = [];
    this.neighbours = [];
    this.positioned = false;
    this.center = new Vector2(0, 0);
    this.rings = [];
    this.isBridged = false;
    this.isPartOfBridged = false;
    this.isSpiro = false;
    this.isFused = false;
    this.centralAngle = 0;
    this.canFlip = true;
  }
  /**
   * Clones this ring and returns the clone.
   *
   * @returns {Ring} A clone of this ring.
   */
  clone() {
    const clone = new _Ring(this.members);
    clone.id = this.id;
    clone.insiders = ArrayHelper.clone(this.insiders);
    clone.neighbours = ArrayHelper.clone(this.neighbours);
    clone.positioned = this.positioned;
    clone.center = this.center.clone();
    clone.rings = ArrayHelper.clone(this.rings);
    clone.isBridged = this.isBridged;
    clone.isPartOfBridged = this.isPartOfBridged;
    clone.isSpiro = this.isSpiro;
    clone.isFused = this.isFused;
    clone.centralAngle = this.centralAngle;
    clone.canFlip = this.canFlip;
    return clone;
  }
  /**
   * Returns the size (number of members) of this ring.
   *
   * @returns {Number} The size (number of members) of this ring.
   */
  getSize() {
    return this.members.length;
  }
  /**
   * Gets the polygon representation (an array of the ring-members positional vectors) of this ring.
   *
   * @param {Vertex[]} vertices An array of vertices representing the current molecule.
   * @returns {Vector2[]} An array of the positional vectors of the ring members.
   */
  getPolygon(vertices) {
    const polygon = [];
    for (let i = 0; i < this.members.length; i++) {
      polygon.push(vertices[this.members[i]].position);
    }
    return polygon;
  }
  /**
   * Returns the angle of this ring in relation to the coordinate system.
   *
   * @returns {Number} The angle in radians.
   */
  getAngle() {
    return Math.PI - this.centralAngle;
  }
  /**
   * Loops over the members of this ring from a given start position in a direction opposite to the vertex id passed as the previousId.
   *
   * @param {Vertex[]} vertices The vertices associated with the current molecule.
   * @param {Function} callback A callback with the current vertex id as a parameter.
   * @param {Number} startVertexId The vertex id of the start vertex.
   * @param {Number} previousVertexId The vertex id of the previous vertex (the loop calling the callback function will run in the opposite direction of this vertex).
   */
  eachMember(vertices, callback, startVertexId, previousVertexId) {
    startVertexId = startVertexId || startVertexId === 0 ? startVertexId : this.members[0];
    let current = startVertexId;
    let max = 0;
    while (current !== null && max < 100) {
      const prev = current;
      callback(prev);
      current = vertices[current].getNextInRing(
        vertices,
        this.id,
        previousVertexId
      );
      previousVertexId = prev;
      if (current === startVertexId) {
        current = null;
      }
      max++;
    }
  }
  /**
   * Returns an array containing the neighbouring rings of this ring ordered by ring size.
   *
   * @param {RingConnection[]} ringConnections An array of ring connections associated with the current molecule.
   * @returns {Object[]} An array of neighbouring rings sorted by ring size. Example: { n: 5, neighbour: 1 }.
   */
  getOrderedNeighbours(ringConnections) {
    const orderedNeighbours = Array(this.neighbours.length);
    for (let i = 0; i < this.neighbours.length; i++) {
      const vertices = RingConnection.getVertices(
        ringConnections,
        this.id,
        this.neighbours[i]
      );
      orderedNeighbours[i] = {
        n: vertices.length,
        neighbour: this.neighbours[i]
      };
    }
    orderedNeighbours.sort(function(a, b) {
      return b.n - a.n;
    });
    return orderedNeighbours;
  }
  /**
   * Check whether this ring is an implicitly defined benzene-like (e.g. C1=CC=CC=C1) with 6 members and 3 double bonds.
   *
   * @param {Vertex[]} vertices An array of vertices associated with the current molecule.
   * @returns {Boolean} A boolean indicating whether or not this ring is an implicitly defined benzene-like.
   */
  isBenzeneLike(vertices) {
    const db = this.getDoubleBondCount(vertices);
    const length = this.members.length;
    return db === 3 && length === 6 || db === 2 && length === 5;
  }
  /**
   * Get the number of double bonds inside this ring.
   *
   * @param {Vertex[]} vertices An array of vertices associated with the current molecule.
   * @returns {Number} The number of double bonds inside this ring.
   */
  getDoubleBondCount(vertices) {
    let doubleBondCount = 0;
    for (let i = 0; i < this.members.length; i++) {
      const atom = vertices[this.members[i]].value;
      if (atom.bondType === "=" || atom.branchBond === "=") {
        doubleBondCount++;
      }
    }
    return doubleBondCount;
  }
  /**
   * Checks whether or not this ring contains a member with a given vertex id.
   *
   * @param {Number} vertexId A vertex id.
   * @returns {Boolean} A boolean indicating whether or not this ring contains a member with the given vertex id.
   */
  contains(vertexId) {
    for (let i = 0; i < this.members.length; i++) {
      if (this.members[i] === vertexId) {
        return true;
      }
    }
    return false;
  }
};

// src/UtilityFunctions.ts
function getChargeText(charge) {
  if (charge === 1) {
    return "+";
  } else if (charge === 2) {
    return "2+";
  } else if (charge === -1) {
    return "-";
  } else if (charge === -2) {
    return "2-";
  } else {
    return "";
  }
}

// src/CanvasWrapper.ts
var CanvasWrapper = class {
  canvas;
  ctx;
  themeManager;
  opts;
  drawingWidth;
  drawingHeight;
  offsetX;
  offsetY;
  fontLarge;
  fontSmall;
  hydrogenWidth;
  halfHydrogenWidth;
  halfBondThickness;
  devicePixelRatio;
  backingStoreRatio;
  ratio;
  colors;
  /**
   * The constructor for the class CanvasWrapper.
   *
   * @param {(String|HTMLElement)} target The canvas id or the canvas HTMLElement.
   * @param {ThemeManager} themeManager Theme manager for setting proper colors.
   * @param {Object} options The smiles drawer options object.
   */
  constructor(target, themeManager, options) {
    if (typeof target === "string" || target instanceof String) {
      this.canvas = document.getElementById(target);
    } else {
      this.canvas = target;
    }
    this.ctx = this.canvas.getContext("2d");
    this.themeManager = themeManager;
    this.opts = options;
    this.drawingWidth = 0;
    this.drawingHeight = 0;
    this.offsetX = 0;
    this.offsetY = 0;
    this.fontLarge = this.opts.fontSizeLarge + "pt Helvetica, Arial, sans-serif";
    this.fontSmall = this.opts.fontSizeSmall + "pt Helvetica, Arial, sans-serif";
    this.updateSize(this.opts.width, this.opts.height);
    this.ctx.font = this.fontLarge;
    this.hydrogenWidth = this.ctx.measureText("H").width;
    this.halfHydrogenWidth = this.hydrogenWidth / 2;
    this.halfBondThickness = this.opts.bondThickness / 2;
  }
  /**
   * Update the width and height of the canvas
   *
   * @param {Number} width
   * @param {Number} height
   */
  updateSize(width, height) {
    this.devicePixelRatio = window.devicePixelRatio || 1;
    this.backingStoreRatio = this.ctx.webkitBackingStorePixelRatio || this.ctx.mozBackingStorePixelRatio || this.ctx.msBackingStorePixelRatio || this.ctx.oBackingStorePixelRatio || this.ctx.backingStorePixelRatio || 1;
    this.ratio = this.devicePixelRatio / this.backingStoreRatio;
    if (this.ratio !== 1) {
      this.canvas.width = width * this.ratio;
      this.canvas.height = height * this.ratio;
      this.canvas.style.width = width + "px";
      this.canvas.style.height = height + "px";
      this.ctx.setTransform(this.ratio, 0, 0, this.ratio, 0, 0);
    } else {
      this.canvas.width = width * this.ratio;
      this.canvas.height = height * this.ratio;
    }
  }
  /**
   * Sets a provided theme.
   *
   * @param {Object} theme A theme from the smiles drawer options.
   */
  setTheme(theme) {
    this.colors = theme;
  }
  /**
   * Scale the canvas based on vertex positions.
   *
   * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.
   */
  scale(vertices) {
    let maxX = -Number.MAX_VALUE;
    let maxY = -Number.MAX_VALUE;
    let minX = Number.MAX_VALUE;
    let minY = Number.MAX_VALUE;
    for (let i = 0; i < vertices.length; i++) {
      if (!vertices[i].value.isDrawn) {
        continue;
      }
      const p = vertices[i].position;
      if (maxX < p.x) {
        maxX = p.x;
      }
      if (maxY < p.y) {
        maxY = p.y;
      }
      if (minX > p.x) {
        minX = p.x;
      }
      if (minY > p.y) {
        minY = p.y;
      }
    }
    const padding = this.opts.padding;
    maxX += padding;
    maxY += padding;
    minX -= padding;
    minY -= padding;
    this.drawingWidth = maxX - minX;
    this.drawingHeight = maxY - minY;
    const scaleX = this.canvas.offsetWidth / this.drawingWidth;
    const scaleY = this.canvas.offsetHeight / this.drawingHeight;
    const scale = scaleX < scaleY ? scaleX : scaleY;
    this.ctx.scale(scale, scale);
    this.offsetX = -minX;
    this.offsetY = -minY;
    if (scaleX < scaleY) {
      this.offsetY += this.canvas.offsetHeight / (2 * scale) - this.drawingHeight / 2;
    } else {
      this.offsetX += this.canvas.offsetWidth / (2 * scale) - this.drawingWidth / 2;
    }
  }
  /**
   * Resets the transform of the canvas.
   */
  reset() {
    this.ctx.setTransform(1, 0, 0, 1, 0, 0);
  }
  /**
   * Returns the hex code of a color associated with a key from the current theme.
   *
   * @param {String} key The color key in the theme (e.g. C, N, BACKGROUND, ...).
   * @returns {String} A color hex value.
   */
  getColor(key) {
    key = key.toUpperCase();
    if (key in this.colors) {
      return this.colors[key];
    }
    return this.colors["C"];
  }
  /**
   * Draws a circle to a canvas context.
   * @param {Number} x The x coordinate of the circles center.
   * @param {Number} y The y coordinate of the circles center.
   * @param {Number} radius The radius of the circle
   * @param {String} color A hex encoded color.
   * @param {Boolean} [fill=true] Whether to fill or stroke the circle.
   * @param {Boolean} [debug=false] Draw in debug mode.
   * @param {String} [debugText=''] A debug message.
   */
  drawCircle(x, y, radius, color, fill = true, debug = false, debugText = "") {
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    ctx.save();
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(x + offsetX, y + offsetY, radius, 0, MathHelper.twoPI, true);
    ctx.closePath();
    if (debug) {
      if (fill) {
        ctx.fillStyle = "#f00";
        ctx.fill();
      } else {
        ctx.strokeStyle = "#f00";
        ctx.stroke();
      }
      this.drawDebugText(x, y, debugText);
    } else {
      if (fill) {
        ctx.fillStyle = color;
        ctx.fill();
      } else {
        ctx.strokeStyle = color;
        ctx.stroke();
      }
    }
    ctx.restore();
  }
  /**
   * Draw a line to a canvas.
   *
   * @param {Line} line A line.
   * @param {Boolean} [dashed=false] Whether or not the line is dashed.
   * @param {Number} [alpha=1.0] The alpha value of the color.
   */
  drawLine(line, dashed = false, alpha = 1) {
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    const shortLine = line.clone().shorten(4);
    let l = shortLine.getLeftVector().clone();
    let r = shortLine.getRightVector().clone();
    l.x += offsetX;
    l.y += offsetY;
    r.x += offsetX;
    r.y += offsetY;
    if (!dashed) {
      ctx.save();
      ctx.globalCompositeOperation = "destination-out";
      ctx.beginPath();
      ctx.moveTo(l.x, l.y);
      ctx.lineTo(r.x, r.y);
      ctx.lineCap = "round";
      ctx.lineWidth = this.opts.bondThickness + 1.2;
      ctx.strokeStyle = this.themeManager.getColor("BACKGROUND");
      ctx.stroke();
      ctx.globalCompositeOperation = "source-over";
      ctx.restore();
    }
    l = line.getLeftVector().clone();
    r = line.getRightVector().clone();
    l.x += offsetX;
    l.y += offsetY;
    r.x += offsetX;
    r.y += offsetY;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(l.x, l.y);
    ctx.lineTo(r.x, r.y);
    ctx.lineCap = "round";
    ctx.lineWidth = this.opts.bondThickness;
    const gradient = this.ctx.createLinearGradient(l.x, l.y, r.x, r.y);
    gradient.addColorStop(
      0.4,
      this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C")
    );
    gradient.addColorStop(
      0.6,
      this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C")
    );
    if (dashed) {
      ctx.setLineDash([1, 1.5]);
      ctx.lineWidth = this.opts.bondThickness / 1.5;
    }
    if (alpha < 1) {
      ctx.globalAlpha = alpha;
    }
    ctx.strokeStyle = gradient;
    ctx.stroke();
    ctx.restore();
  }
  /**
   * Draw a wedge on the canvas.
   *
   * @param {Line} line A line.
   * @param {Number} width The wedge width.
   */
  drawWedge(line, width = 1) {
    if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
      return;
    }
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    const shortLine = line.clone().shorten(5);
    let l = shortLine.getLeftVector().clone();
    let r = shortLine.getRightVector().clone();
    l.x += offsetX;
    l.y += offsetY;
    r.x += offsetX;
    r.y += offsetY;
    l = line.getLeftVector().clone();
    r = line.getRightVector().clone();
    l.x += offsetX;
    l.y += offsetY;
    r.x += offsetX;
    r.y += offsetY;
    ctx.save();
    const normals = Vector2.normals(l, r);
    normals[0].normalize();
    normals[1].normalize();
    const isRightChiralCenter = line.getRightChiral();
    let start = l;
    let end = r;
    if (isRightChiralCenter) {
      start = r;
      end = l;
    }
    const t = Vector2.add(
      start,
      Vector2.multiplyScalar(normals[0], this.halfBondThickness)
    );
    const u = Vector2.add(
      end,
      Vector2.multiplyScalar(normals[0], 1.5 + this.halfBondThickness)
    );
    const v = Vector2.add(
      end,
      Vector2.multiplyScalar(normals[1], 1.5 + this.halfBondThickness)
    );
    const w = Vector2.add(
      start,
      Vector2.multiplyScalar(normals[1], this.halfBondThickness)
    );
    ctx.beginPath();
    ctx.moveTo(t.x, t.y);
    ctx.lineTo(u.x, u.y);
    ctx.lineTo(v.x, v.y);
    ctx.lineTo(w.x, w.y);
    const gradient = this.ctx.createRadialGradient(
      r.x,
      r.y,
      this.opts.bondLength,
      r.x,
      r.y,
      0
    );
    gradient.addColorStop(
      0.4,
      this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C")
    );
    gradient.addColorStop(
      0.6,
      this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C")
    );
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  }
  /**
   * Draw a dashed wedge on the canvas.
   *
   * @param {Line} line A line.
   */
  drawDashedWedge(line) {
    if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
      return;
    }
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    const l = line.getLeftVector().clone();
    const r = line.getRightVector().clone();
    l.x += offsetX;
    l.y += offsetY;
    r.x += offsetX;
    r.y += offsetY;
    ctx.save();
    const normals = Vector2.normals(l, r);
    normals[0].normalize();
    normals[1].normalize();
    const isRightChiralCenter = line.getRightChiral();
    let start;
    let end;
    let sStart;
    let sEnd;
    const shortLine = line.clone();
    if (isRightChiralCenter) {
      start = r;
      end = l;
      shortLine.shortenRight(1);
      sStart = shortLine.getRightVector().clone();
      sEnd = shortLine.getLeftVector().clone();
    } else {
      start = l;
      end = r;
      shortLine.shortenLeft(1);
      sStart = shortLine.getLeftVector().clone();
      sEnd = shortLine.getRightVector().clone();
    }
    sStart.x += offsetX;
    sStart.y += offsetY;
    sEnd.x += offsetX;
    sEnd.y += offsetY;
    const dir = Vector2.subtract(end, start).normalize();
    ctx.strokeStyle = this.themeManager.getColor("C");
    ctx.lineCap = "round";
    ctx.lineWidth = this.opts.bondThickness;
    ctx.beginPath();
    const length = line.getLength();
    const step = 1.25 / (length / (this.opts.bondThickness * 3));
    let changed = false;
    for (let t = 0; t < 1; t += step) {
      const to = Vector2.multiplyScalar(dir, t * length);
      const startDash = Vector2.add(start, to);
      const width = 1.5 * t;
      const dashOffset = Vector2.multiplyScalar(normals[0], width);
      if (!changed && t > 0.5) {
        ctx.stroke();
        ctx.beginPath();
        ctx.strokeStyle = this.themeManager.getColor(line.getRightElement()) || this.themeManager.getColor("C");
        changed = true;
      }
      startDash.subtract(dashOffset);
      ctx.moveTo(startDash.x, startDash.y);
      startDash.add(Vector2.multiplyScalar(dashOffset, 2));
      ctx.lineTo(startDash.x, startDash.y);
    }
    ctx.stroke();
    ctx.restore();
  }
  /**
   * Draws a debug text message at a given position
   *
   * @param {Number} x The x coordinate.
   * @param {Number} y The y coordinate.
   * @param {String} text The debug text.
   */
  drawDebugText(x, y, text) {
    const ctx = this.ctx;
    ctx.save();
    ctx.font = "5px Droid Sans, sans-serif";
    ctx.textAlign = "start";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#ff0000";
    ctx.fillText(text, x + this.offsetX, y + this.offsetY);
    ctx.restore();
  }
  /**
   * Draw a ball to the canvas.
   *
   * @param {Number} x The x position of the text.
   * @param {Number} y The y position of the text.
   * @param {String} elementName The name of the element (single-letter).
   */
  drawBall(x, y, elementName) {
    const ctx = this.ctx;
    ctx.save();
    ctx.beginPath();
    ctx.arc(
      x + this.offsetX,
      y + this.offsetY,
      this.opts.bondLength / 4.5,
      0,
      MathHelper.twoPI,
      false
    );
    ctx.fillStyle = this.themeManager.getColor(elementName);
    ctx.fill();
    ctx.restore();
  }
  /**
   * Draw a point to the canvas.
   *
   * @param {Number} x The x position of the point.
   * @param {Number} y The y position of the point.
   * @param {String} elementName The name of the element (single-letter).
   */
  drawPoint(x, y, elementName) {
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    ctx.save();
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.arc(x + offsetX, y + offsetY, 1.5, 0, MathHelper.twoPI, true);
    ctx.closePath();
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
    ctx.beginPath();
    ctx.arc(
      x + this.offsetX,
      y + this.offsetY,
      0.75,
      0,
      MathHelper.twoPI,
      false
    );
    ctx.fillStyle = this.themeManager.getColor(elementName);
    ctx.fill();
    ctx.restore();
  }
  /**
   * Draw a text to the canvas.
   *
   * @param {Number} x The x position of the text.
   * @param {Number} y The y position of the text.
   * @param {String} elementName The name of the element (single-letter).
   * @param {Number} hydrogens The number of hydrogen atoms.
   * @param {String} direction The direction of the text in relation to the associated vertex.
   * @param {Boolean} isTerminal A boolean indicating whether or not the vertex is terminal.
   * @param {Number} charge The charge of the atom.
   * @param {Number} isotope The isotope number.
   * @param {Number} vertexCount The number of vertices in the molecular graph.
   * @param {Object} attachedPseudoElement A map with containing information for pseudo elements or concatinated elements. The key is comprised of the element symbol and the hydrogen count.
   * @param {String} attachedPseudoElement.element The element symbol.
   * @param {Number} attachedPseudoElement.count The number of occurences that match the key.
   * @param {Number} attachedPseudoElement.hyrogenCount The number of hydrogens attached to each atom matching the key.
   */
  drawText(x, y, elementName, hydrogens, direction, isTerminal, charge, isotope, vertexCount, attachedPseudoElement = {}) {
    const ctx = this.ctx;
    const offsetX = this.offsetX;
    const offsetY = this.offsetY;
    ctx.save();
    ctx.textAlign = "start";
    ctx.textBaseline = "alphabetic";
    const pseudoElementHandled = false;
    let chargeText = "";
    let chargeWidth = 0;
    if (charge) {
      chargeText = getChargeText(charge);
      ctx.font = this.fontSmall;
      chargeWidth = ctx.measureText(chargeText).width;
    }
    let isotopeText = "0";
    let isotopeWidth = 0;
    if (isotope > 0) {
      isotopeText = isotope.toString();
      ctx.font = this.fontSmall;
      isotopeWidth = ctx.measureText(isotopeText).width;
    }
    if (charge === 1 && elementName === "N" && attachedPseudoElement.hasOwnProperty("0O") && attachedPseudoElement.hasOwnProperty("0O-1")) {
      attachedPseudoElement = {
        "0O": {
          element: "O",
          count: 2,
          hydrogenCount: 0,
          previousElement: "C",
          charge: ""
        }
      };
      charge = 0;
    }
    ctx.font = this.fontLarge;
    ctx.fillStyle = this.themeManager.getColor("BACKGROUND");
    const dim = ctx.measureText(elementName);
    dim.totalWidth = dim.width + chargeWidth;
    dim.height = parseInt(this.fontLarge, 10);
    let r = dim.width > this.opts.fontSizeLarge ? dim.width : this.opts.fontSizeLarge;
    r /= 1.5;
    ctx.globalCompositeOperation = "destination-out";
    ctx.beginPath();
    ctx.arc(x + offsetX, y + offsetY, r, 0, MathHelper.twoPI, true);
    ctx.closePath();
    ctx.fill();
    ctx.globalCompositeOperation = "source-over";
    let cursorPos = -dim.width / 2;
    let cursorPosLeft = -dim.width / 2;
    ctx.fillStyle = this.themeManager.getColor(elementName);
    ctx.fillText(
      elementName,
      x + offsetX + cursorPos,
      y + this.opts.halfFontSizeLarge + offsetY
    );
    cursorPos += dim.width;
    if (charge) {
      ctx.font = this.fontSmall;
      ctx.fillText(
        chargeText,
        x + offsetX + cursorPos,
        y - this.opts.fifthFontSizeSmall + offsetY
      );
      cursorPos += chargeWidth;
    }
    if (isotope > 0) {
      ctx.font = this.fontSmall;
      ctx.fillText(
        isotopeText,
        x + offsetX + cursorPosLeft - isotopeWidth,
        y - this.opts.fifthFontSizeSmall + offsetY
      );
      cursorPosLeft -= isotopeWidth;
    }
    ctx.font = this.fontLarge;
    let hydrogenWidth = 0;
    let hydrogenCountWidth = 0;
    if (hydrogens === 1) {
      let hx = x + offsetX;
      let hy = y + offsetY + this.opts.halfFontSizeLarge;
      hydrogenWidth = this.hydrogenWidth;
      cursorPosLeft -= hydrogenWidth;
      if (direction === "left") {
        hx += cursorPosLeft;
      } else if (direction === "right") {
        hx += cursorPos;
      } else if (direction === "up" && isTerminal) {
        hx += cursorPos;
      } else if (direction === "down" && isTerminal) {
        hx += cursorPos;
      } else if (direction === "up" && !isTerminal) {
        hy -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
        hx -= this.halfHydrogenWidth;
      } else if (direction === "down" && !isTerminal) {
        hy += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
        hx -= this.halfHydrogenWidth;
      }
      ctx.fillText("H", hx, hy);
      cursorPos += hydrogenWidth;
    } else if (hydrogens > 1) {
      let hx = x + offsetX;
      let hy = y + offsetY + this.opts.halfFontSizeLarge;
      hydrogenWidth = this.hydrogenWidth;
      ctx.font = this.fontSmall;
      hydrogenCountWidth = ctx.measureText(hydrogens).width;
      cursorPosLeft -= hydrogenWidth + hydrogenCountWidth;
      if (direction === "left") {
        hx += cursorPosLeft;
      } else if (direction === "right") {
        hx += cursorPos;
      } else if (direction === "up" && isTerminal) {
        hx += cursorPos;
      } else if (direction === "down" && isTerminal) {
        hx += cursorPos;
      } else if (direction === "up" && !isTerminal) {
        hy -= this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
        hx -= this.halfHydrogenWidth;
      } else if (direction === "down" && !isTerminal) {
        hy += this.opts.fontSizeLarge + this.opts.quarterFontSizeLarge;
        hx -= this.halfHydrogenWidth;
      }
      ctx.font = this.fontLarge;
      ctx.fillText("H", hx, hy);
      ctx.font = this.fontSmall;
      ctx.fillText(
        hydrogens,
        hx + this.halfHydrogenWidth + hydrogenCountWidth,
        hy + this.opts.fifthFontSizeSmall
      );
      cursorPos += hydrogenWidth + this.halfHydrogenWidth + hydrogenCountWidth;
    }
    if (pseudoElementHandled) {
      ctx.restore();
      return;
    }
    for (const key in attachedPseudoElement) {
      if (!attachedPseudoElement.hasOwnProperty(key)) {
        continue;
      }
      let openParenthesisWidth = 0;
      let closeParenthesisWidth = 0;
      const element = attachedPseudoElement[key].element;
      const elementCount = attachedPseudoElement[key].count;
      const hydrogenCount = attachedPseudoElement[key].hydrogenCount;
      const elementCharge = attachedPseudoElement[key].charge;
      ctx.font = this.fontLarge;
      if (elementCount > 1 && hydrogenCount > 0) {
        openParenthesisWidth = ctx.measureText("(").width;
        closeParenthesisWidth = ctx.measureText(")").width;
      }
      const elementWidth = ctx.measureText(element).width;
      let elementCountWidth = 0;
      let elementChargeText = "";
      let elementChargeWidth = 0;
      hydrogenWidth = 0;
      if (hydrogenCount > 0) {
        hydrogenWidth = this.hydrogenWidth;
      }
      ctx.font = this.fontSmall;
      if (elementCount > 1) {
        elementCountWidth = ctx.measureText(elementCount).width;
      }
      if (elementCharge !== 0) {
        elementChargeText = getChargeText(elementCharge);
        elementChargeWidth = ctx.measureText(elementChargeText).width;
      }
      hydrogenCountWidth = 0;
      if (hydrogenCount > 1) {
        hydrogenCountWidth = ctx.measureText(hydrogenCount).width;
      }
      ctx.font = this.fontLarge;
      const hx = x + offsetX;
      const hy = y + offsetY + this.opts.halfFontSizeLarge;
      ctx.fillStyle = this.themeManager.getColor(element);
      if (elementCount > 0) {
        cursorPosLeft -= elementCountWidth;
      }
      if (elementCount > 1 && hydrogenCount > 0) {
        if (direction === "left") {
          cursorPosLeft -= closeParenthesisWidth;
          ctx.fillText(")", hx + cursorPosLeft, hy);
        } else {
          ctx.fillText("(", hx + cursorPos, hy);
          cursorPos += openParenthesisWidth;
        }
      }
      if (direction === "left") {
        cursorPosLeft -= elementWidth;
        ctx.fillText(element, hx + cursorPosLeft, hy);
      } else {
        ctx.fillText(element, hx + cursorPos, hy);
        cursorPos += elementWidth;
      }
      if (hydrogenCount > 0) {
        if (direction === "left") {
          cursorPosLeft -= hydrogenWidth + hydrogenCountWidth;
          ctx.fillText("H", hx + cursorPosLeft, hy);
          if (hydrogenCount > 1) {
            ctx.font = this.fontSmall;
            ctx.fillText(
              hydrogenCount,
              hx + cursorPosLeft + hydrogenWidth,
              hy + this.opts.fifthFontSizeSmall
            );
          }
        } else {
          ctx.fillText("H", hx + cursorPos, hy);
          cursorPos += hydrogenWidth;
          if (hydrogenCount > 1) {
            ctx.font = this.fontSmall;
            ctx.fillText(
              hydrogenCount,
              hx + cursorPos,
              hy + this.opts.fifthFontSizeSmall
            );
            cursorPos += hydrogenCountWidth;
          }
        }
      }
      ctx.font = this.fontLarge;
      if (elementCount > 1 && hydrogenCount > 0) {
        if (direction === "left") {
          cursorPosLeft -= openParenthesisWidth;
          ctx.fillText("(", hx + cursorPosLeft, hy);
        } else {
          ctx.fillText(")", hx + cursorPos, hy);
          cursorPos += closeParenthesisWidth;
        }
      }
      ctx.font = this.fontSmall;
      if (elementCount > 1) {
        if (direction === "left") {
          ctx.fillText(
            elementCount,
            hx + cursorPosLeft + openParenthesisWidth + closeParenthesisWidth + hydrogenWidth + hydrogenCountWidth + elementWidth,
            hy + this.opts.fifthFontSizeSmall
          );
        } else {
          ctx.fillText(
            elementCount,
            hx + cursorPos,
            hy + this.opts.fifthFontSizeSmall
          );
          cursorPos += elementCountWidth;
        }
      }
      if (elementCharge !== 0) {
        if (direction === "left") {
          ctx.fillText(
            elementChargeText,
            hx + cursorPosLeft + openParenthesisWidth + closeParenthesisWidth + hydrogenWidth + hydrogenCountWidth + elementWidth,
            y - this.opts.fifthFontSizeSmall + offsetY
          );
        } else {
          ctx.fillText(
            elementChargeText,
            hx + cursorPos,
            y - this.opts.fifthFontSizeSmall + offsetY
          );
          cursorPos += elementChargeWidth;
        }
      }
    }
    ctx.restore();
  }
  /**
   * Translate the integer indicating the charge to the appropriate text.
   * @param {Number} charge The integer indicating the charge.
   * @returns {String} A string representing a charge.
   */
  getChargeText(charge) {
    if (charge === 1) {
      return "+";
    } else if (charge === 2) {
      return "2+";
    } else if (charge === -1) {
      return "-";
    } else if (charge === -2) {
      return "2-";
    } else {
      return "";
    }
  }
  /**
   * Draws a dubug dot at a given coordinate and adds text.
   *
   * @param {Number} x The x coordinate.
   * @param {Number} y The y coordindate.
   * @param {String} [debugText=''] A string.
   * @param {String} [color='#f00'] A color in hex form.
   */
  drawDebugPoint(x, y, debugText = "", color = "#f00") {
    this.drawCircle(x, y, 2, color, true, true, debugText);
  }
  /**
   * Draws a ring inside a provided ring, indicating aromaticity.
   *
   * @param {Ring} ring A ring.
   */
  drawAromaticityRing(ring) {
    const ctx = this.ctx;
    const radius = MathHelper.apothemFromSideLength(
      this.opts.bondLength,
      ring.getSize()
    );
    ctx.save();
    ctx.strokeStyle = this.themeManager.getColor("C");
    ctx.lineWidth = this.opts.bondThickness;
    ctx.beginPath();
    ctx.arc(
      ring.center.x + this.offsetX,
      ring.center.y + this.offsetY,
      radius - this.opts.bondSpacing,
      0,
      Math.PI * 2,
      true
    );
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }
  /**
   * Clear the canvas.
   *
   */
  clear() {
    this.ctx.clearRect(0, 0, this.canvas.offsetWidth, this.canvas.offsetHeight);
  }
};

// src/Vertex.ts
var Vertex = class _Vertex {
  id;
  value;
  position;
  previousPosition;
  parentVertexId;
  children;
  spanningTreeChildren;
  edges;
  positioned;
  angle;
  dir;
  neighbourCount;
  neighbours;
  neighbouringElements;
  forcePositioned;
  /**
   * The constructor for the class Vertex.
   *
   * @param {Atom} value The value associated with this vertex.
   * @param {Number} [x=0] The initial x coordinate of the positional vector of this vertex.
   * @param {Number} [y=0] The initial y coordinate of the positional vector of this vertex.
   */
  constructor(value, x = 0, y = 0) {
    this.id = null;
    this.value = value;
    this.position = new Vector2(x ? x : 0, y ? y : 0);
    this.previousPosition = new Vector2(0, 0);
    this.parentVertexId = null;
    this.children = [];
    this.spanningTreeChildren = [];
    this.edges = [];
    this.positioned = false;
    this.angle = null;
    this.dir = 1;
    this.neighbourCount = 0;
    this.neighbours = [];
    this.neighbouringElements = [];
    this.forcePositioned = false;
  }
  /**
   * Set the 2D coordinates of the vertex.
   *
   * @param {Number} x The x component of the coordinates.
   * @param {Number} y The y component of the coordinates.
   *
   */
  setPosition(x, y) {
    this.position.x = x;
    this.position.y = y;
  }
  /**
   * Set the 2D coordinates of the vertex from a Vector2.
   *
   * @param {Vector2} v A 2D vector.
   *
   */
  setPositionFromVector(v) {
    this.position.x = v.x;
    this.position.y = v.y;
  }
  /**
   * Add a child vertex id to this vertex.
   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.
   */
  addChild(vertexId) {
    this.children.push(vertexId);
    this.neighbours.push(vertexId);
    this.neighbourCount++;
  }
  /**
   * Add a child vertex id to this vertex as the second child of the neighbours array,
   * except this vertex is the first vertex of the SMILE string, then it is added as the first.
   * This is used to get the correct ordering of neighbours for parity calculations.
   * If a hydrogen is implicitly attached to the chiral center, insert as the third child.
   * @param {Number} vertexId The id of a vertex to be added as a child to this vertex.
   * @param {Number} ringbondIndex The index of the ringbond.
   */
  addRingbondChild(vertexId, ringbondIndex) {
    this.children.push(vertexId);
    if (this.value.bracket) {
      let index = 1;
      if (this.id === 0 && this.value.bracket.hcount === 0) {
        index = 0;
      }
      if (this.value.bracket.hcount === 1 && ringbondIndex === 0) {
        index = 2;
      }
      if (this.value.bracket.hcount === 1 && ringbondIndex === 1) {
        if (this.neighbours.length < 3) {
          index = 2;
        } else {
          index = 3;
        }
      }
      if (this.value.bracket.hcount === null && ringbondIndex === 0) {
        index = 1;
      }
      if (this.value.bracket.hcount === null && ringbondIndex === 1) {
        if (this.neighbours.length < 3) {
          index = 1;
        } else {
          index = 2;
        }
      }
      this.neighbours.splice(index, 0, vertexId);
    } else {
      this.neighbours.push(vertexId);
    }
    this.neighbourCount++;
  }
  /**
   * Set the vertex id of the parent.
   *
   * @param {Number} parentVertexId The parents vertex id.
   */
  setParentVertexId(parentVertexId) {
    this.neighbourCount++;
    this.parentVertexId = parentVertexId;
    this.neighbours.push(parentVertexId);
  }
  /**
   * Returns true if this vertex is terminal (has no parent or child vertices), otherwise returns false. Always returns true if associated value has property hasAttachedPseudoElements set to true.
   *
   * @returns {Boolean} A boolean indicating whether or not this vertex is terminal.
   */
  isTerminal() {
    if (this.value.hasAttachedPseudoElements) {
      return true;
    }
    return this.parentVertexId === null && this.children.length < 2 || this.children.length === 0;
  }
  /**
   * Clones this vertex and returns the clone.
   *
   * @returns {Vertex} A clone of this vertex.
   */
  clone() {
    const clone = new _Vertex(this.value, this.position.x, this.position.y);
    clone.id = this.id;
    clone.previousPosition = new Vector2(
      this.previousPosition.x,
      this.previousPosition.y
    );
    clone.parentVertexId = this.parentVertexId;
    clone.children = ArrayHelper.clone(this.children);
    clone.spanningTreeChildren = ArrayHelper.clone(this.spanningTreeChildren);
    clone.edges = ArrayHelper.clone(this.edges);
    clone.positioned = this.positioned;
    clone.angle = this.angle;
    clone.forcePositioned = this.forcePositioned;
    return clone;
  }
  /**
   * Returns true if this vertex and the supplied vertex both have the same id, else returns false.
   *
   * @param {Vertex} vertex The vertex to check.
   * @returns {Boolean} A boolean indicating whether or not the two vertices have the same id.
   */
  equals(vertex) {
    return this.id === vertex.id;
  }
  /**
   * Returns the angle of this vertexes positional vector. If a reference vector is supplied in relations to this vector, else in relations to the coordinate system.
   *
   * @param {Vector2} [referenceVector=null] - The reference vector.
   * @param {Boolean} [returnAsDegrees=false] - If true, returns angle in degrees, else in radians.
   * @returns {Number} The angle of this vertex.
   */
  getAngle(referenceVector = null, returnAsDegrees = false) {
    let u = null;
    if (!referenceVector) {
      u = Vector2.subtract(this.position, this.previousPosition);
    } else {
      u = Vector2.subtract(this.position, referenceVector);
    }
    if (returnAsDegrees) {
      return MathHelper.toDeg(u.angle());
    }
    return u.angle();
  }
  /**
   * Returns the suggested text direction when text is added at the position of this vertex.
   *
   * @param {Vertex[]} vertices The array of vertices for the current molecule.
   * @returns {String} The suggested direction of the text.
   */
  getTextDirection(vertices) {
    const neighbours = this.getDrawnNeighbours(vertices);
    const angles = [];
    if (vertices.length === 1) {
      return "right";
    }
    for (let i = 0; i < neighbours.length; i++) {
      angles.push(this.getAngle(vertices[neighbours[i]].position));
    }
    let textAngle = MathHelper.meanAngle(angles);
    const halfPi = Math.PI / 2;
    textAngle = Math.round(Math.round(textAngle / halfPi) * halfPi);
    if (textAngle === 2) {
      return "down";
    } else if (textAngle === -2) {
      return "up";
    } else if (textAngle === 0 || Object.is(textAngle, -0)) {
      return "right";
    } else if (textAngle === 3 || textAngle === -3) {
      return "left";
    } else {
      return "down";
    }
  }
  /**
   * Returns an array of ids of neighbouring vertices.
   *
   * @param {Number} [vertexId=null] If a value is supplied, the vertex with this id is excluded from the returned indices.
   * @returns {Number[]} An array containing the ids of neighbouring vertices.
   */
  getNeighbours(vertexId = null) {
    if (vertexId === null) {
      return this.neighbours.slice();
    }
    const arr = [];
    for (let i = 0; i < this.neighbours.length; i++) {
      if (this.neighbours[i] !== vertexId) {
        arr.push(this.neighbours[i]);
      }
    }
    return arr;
  }
  /**
   * Returns an array of ids of neighbouring vertices that will be drawn (vertex.value.isDrawn === true).
   *
   * @param {Vertex[]} vertices An array containing the vertices associated with the current molecule.
   * @returns {Number[]} An array containing the ids of neighbouring vertices that will be drawn.
   */
  getDrawnNeighbours(vertices) {
    const arr = [];
    for (let i = 0; i < this.neighbours.length; i++) {
      if (vertices[this.neighbours[i]].value.isDrawn) {
        arr.push(this.neighbours[i]);
      }
    }
    return arr;
  }
  /**
   * Returns the number of neighbours of this vertex.
   *
   * @returns {Number} The number of neighbours.
   */
  getNeighbourCount() {
    return this.neighbourCount;
  }
  /**
   * Returns a list of ids of vertices neighbouring this one in the original spanning tree, excluding the ringbond connections.
   *
   * @param {Number} [vertexId=null] If supplied, the vertex with this id is excluded from the array returned.
   * @returns {Number[]} An array containing the ids of the neighbouring vertices.
   */
  getSpanningTreeNeighbours(vertexId = null) {
    const neighbours = [];
    for (let i = 0; i < this.spanningTreeChildren.length; i++) {
      if (vertexId === void 0 || vertexId !== this.spanningTreeChildren[i]) {
        neighbours.push(this.spanningTreeChildren[i]);
      }
    }
    if (this.parentVertexId !== null) {
      if (vertexId === void 0 || vertexId !== this.parentVertexId) {
        neighbours.push(this.parentVertexId);
      }
    }
    return neighbours;
  }
  /**
   * Gets the next vertex in the ring in opposide direction to the supplied vertex id.
   *
   * @param {Vertex[]} vertices The array of vertices for the current molecule.
   * @param {Number} ringId The id of the ring containing this vertex.
   * @param {Number} previousVertexId The id of the previous vertex. The next vertex will be opposite from the vertex with this id as seen from this vertex.
   * @returns {Number} The id of the next vertex in the ring.
   */
  getNextInRing(vertices, ringId, previousVertexId) {
    const neighbours = this.getNeighbours();
    for (let i = 0; i < neighbours.length; i++) {
      if (ArrayHelper.contains(vertices[neighbours[i]].value.rings, {
        value: ringId
      }) && neighbours[i] !== previousVertexId) {
        return neighbours[i];
      }
    }
    return null;
  }
};

// src/Graph.ts
var Graph = class _Graph {
  vertices;
  edges;
  vertexIdsToEdgeId;
  isomeric;
  _time;
  /**
   * The constructor of the class Graph.
   *
   * @param {Object} parseTree A SMILES parse tree.
   * @param {Boolean} [isomeric=false] A boolean specifying whether or not the SMILES is isomeric.
   */
  constructor(parseTree, isomeric = false) {
    this.vertices = [];
    this.edges = [];
    this.vertexIdsToEdgeId = {};
    this.isomeric = isomeric;
    this._time = 0;
    this._init(parseTree);
  }
  /**
   * PRIVATE FUNCTION. Initializing the graph from the parse tree.
   *
   * @param {Object} node The current node in the parse tree.
   * @param {Number} parentVertexId=null The id of the previous vertex.
   * @param {Boolean} isBranch=false Whether or not the bond leading to this vertex is a branch bond. Branches are represented by parentheses in smiles (e.g. CC(O)C).
   */
  _init(node, order = 0, parentVertexId = null, isBranch = false) {
    const atom = new Atom(
      node.atom.element ? node.atom.element : node.atom,
      node.bond
    );
    atom.branchBond = node.branchBond;
    atom.ringbonds = node.ringbonds;
    atom.bracket = node.atom.element ? node.atom : null;
    atom.class = node.atom.class;
    const vertex = new Vertex(atom);
    const parentVertex = this.vertices[parentVertexId];
    this.addVertex(vertex);
    if (parentVertexId !== null) {
      vertex.setParentVertexId(parentVertexId);
      vertex.value.addNeighbouringElement(parentVertex.value.element);
      parentVertex.addChild(vertex.id);
      parentVertex.value.addNeighbouringElement(atom.element);
      parentVertex.spanningTreeChildren.push(vertex.id);
      const edge = new Edge(parentVertexId, vertex.id, 1);
      let vertexId = null;
      if (isBranch) {
        edge.setBondType(vertex.value.branchBond || "-");
        vertexId = vertex.id;
        edge.setBondType(vertex.value.branchBond || "-");
        vertexId = vertex.id;
      } else {
        edge.setBondType(parentVertex.value.bondType || "-");
        vertexId = parentVertex.id;
      }
      const edgeId = this.addEdge(edge);
    }
    let offset = node.ringbondCount + 1;
    if (atom.bracket) {
      offset += atom.bracket.hcount;
    }
    let stereoHydrogens = 0;
    if (atom.bracket && atom.bracket.chirality) {
      atom.isStereoCenter = true;
      stereoHydrogens = atom.bracket.hcount;
      for (let i = 0; i < stereoHydrogens; i++) {
        this._init(
          {
            atom: "H",
            isBracket: "false",
            branches: [],
            branchCount: 0,
            ringbonds: [],
            ringbondCount: false,
            next: null,
            hasNext: false,
            bond: "-"
          },
          i,
          vertex.id,
          true
        );
      }
    }
    for (let i = 0; i < node.branchCount; i++) {
      this._init(node.branches[i], i + offset, vertex.id, true);
    }
    if (node.hasNext) {
      this._init(node.next, node.branchCount + offset, vertex.id);
    }
  }
  /**
   * Clears all the elements in this graph (edges and vertices).
   */
  clear() {
    this.vertices = [];
    this.edges = [];
    this.vertexIdsToEdgeId = {};
  }
  /**
   * Add a vertex to the graph.
   *
   * @param {Vertex} vertex A new vertex.
   * @returns {Number} The vertex id of the new vertex.
   */
  addVertex(vertex) {
    vertex.id = this.vertices.length;
    this.vertices.push(vertex);
    return vertex.id;
  }
  /**
   * Add an edge to the graph.
   *
   * @param {Edge} edge A new edge.
   * @returns {Number} The edge id of the new edge.
   */
  addEdge(edge) {
    const source = this.vertices[edge.sourceId];
    const target = this.vertices[edge.targetId];
    edge.id = this.edges.length;
    this.edges.push(edge);
    this.vertexIdsToEdgeId[edge.sourceId + "_" + edge.targetId] = edge.id;
    this.vertexIdsToEdgeId[edge.targetId + "_" + edge.sourceId] = edge.id;
    edge.isPartOfAromaticRing = source.value.isPartOfAromaticRing && target.value.isPartOfAromaticRing;
    source.value.bondCount += edge.weight;
    target.value.bondCount += edge.weight;
    source.edges.push(edge.id);
    target.edges.push(edge.id);
    return edge.id;
  }
  /**
   * Returns the edge between two given vertices.
   *
   * @param {Number} vertexIdA A vertex id.
   * @param {Number} vertexIdB A vertex id.
   * @returns {(Edge|null)} The edge or, if no edge can be found, null.
   */
  getEdge(vertexIdA, vertexIdB) {
    const edgeId = this.vertexIdsToEdgeId[vertexIdA + "_" + vertexIdB];
    return edgeId === void 0 ? null : this.edges[edgeId];
  }
  /**
   * Returns the ids of edges connected to a vertex.
   *
   * @param {Number} vertexId A vertex id.
   * @returns {Number[]} An array containing the ids of edges connected to the vertex.
   */
  getEdges(vertexId) {
    const edgeIds = [];
    const vertex = this.vertices[vertexId];
    for (let i = 0; i < vertex.neighbours.length; i++) {
      edgeIds.push(
        this.vertexIdsToEdgeId[vertexId + "_" + vertex.neighbours[i]]
      );
    }
    return edgeIds;
  }
  /**
   * Check whether or not two vertices are connected by an edge.
   *
   * @param {Number} vertexIdA A vertex id.
   * @param {Number} vertexIdB A vertex id.
   * @returns {Boolean} A boolean indicating whether or not two vertices are connected by an edge.
   */
  hasEdge(vertexIdA, vertexIdB) {
    return this.vertexIdsToEdgeId[vertexIdA + "_" + vertexIdB] !== void 0;
  }
  /**
   * Returns an array containing the vertex ids of this graph.
   *
   * @returns {Number[]} An array containing all vertex ids of this graph.
   */
  getVertexList() {
    const arr = [this.vertices.length];
    for (let i = 0; i < this.vertices.length; i++) {
      arr[i] = this.vertices[i].id;
    }
    return arr;
  }
  /**
   * Returns an array containing source, target arrays of this graphs edges.
   *
   * @returns {Array[]} An array containing source, target arrays of this graphs edges. Example: [ [ 2, 5 ], [ 6, 9 ] ].
   */
  getEdgeList() {
    const arr = Array(this.edges.length);
    for (let i = 0; i < this.edges.length; i++) {
      arr[i] = [this.edges[i].sourceId, this.edges[i].targetId];
    }
    return arr;
  }
  /**
   * Get the adjacency matrix of the graph.
   *
   * @returns {Array[]} The adjancency matrix of the molecular graph.
   */
  getAdjacencyMatrix() {
    const length = this.vertices.length;
    const adjacencyMatrix = Array(length);
    for (let i = 0; i < length; i++) {
      adjacencyMatrix[i] = new Array(length);
      adjacencyMatrix[i].fill(0);
    }
    for (let i = 0; i < this.edges.length; i++) {
      const edge = this.edges[i];
      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;
      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;
    }
    return adjacencyMatrix;
  }
  /**
   * Get the adjacency matrix of the graph with all bridges removed (thus the components). Thus the remaining vertices are all part of ring systems.
   *
   * @returns {Array[]} The adjancency matrix of the molecular graph with all bridges removed.
   */
  getComponentsAdjacencyMatrix() {
    const length = this.vertices.length;
    const adjacencyMatrix = Array(length);
    const bridges = this.getBridges();
    for (let i = 0; i < length; i++) {
      adjacencyMatrix[i] = new Array(length);
      adjacencyMatrix[i].fill(0);
    }
    for (let i = 0; i < this.edges.length; i++) {
      const edge = this.edges[i];
      adjacencyMatrix[edge.sourceId][edge.targetId] = 1;
      adjacencyMatrix[edge.targetId][edge.sourceId] = 1;
    }
    for (let i = 0; i < bridges.length; i++) {
      adjacencyMatrix[bridges[i][0]][bridges[i][1]] = 0;
      adjacencyMatrix[bridges[i][1]][bridges[i][0]] = 0;
    }
    return adjacencyMatrix;
  }
  /**
   * Get the adjacency matrix of a subgraph.
   *
   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.
   * @returns {Array[]} The adjancency matrix of the subgraph.
   */
  getSubgraphAdjacencyMatrix(vertexIds) {
    const length = vertexIds.length;
    const adjacencyMatrix = Array(length);
    for (let i = 0; i < length; i++) {
      adjacencyMatrix[i] = new Array(length);
      adjacencyMatrix[i].fill(0);
      for (let j = 0; j < length; j++) {
        if (i === j) {
          continue;
        }
        if (this.hasEdge(vertexIds[i], vertexIds[j])) {
          adjacencyMatrix[i][j] = 1;
        }
      }
    }
    return adjacencyMatrix;
  }
  /**
   * Get the distance matrix of the graph.
   *
   * @returns {Array[]} The distance matrix of the graph.
   */
  getDistanceMatrix() {
    const length = this.vertices.length;
    const adja = this.getAdjacencyMatrix();
    const dist = Array(length);
    for (let i = 0; i < length; i++) {
      dist[i] = Array(length);
      dist[i].fill(Infinity);
    }
    for (let i = 0; i < length; i++) {
      for (let j = 0; j < length; j++) {
        if (adja[i][j] === 1) {
          dist[i][j] = 1;
        }
      }
    }
    for (let k = 0; k < length; k++) {
      for (let i = 0; i < length; i++) {
        for (let j = 0; j < length; j++) {
          if (dist[i][j] > dist[i][k] + dist[k][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
          }
        }
      }
    }
    return dist;
  }
  /**
   * Get the distance matrix of a subgraph.
   *
   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.
   * @returns {Array[]} The distance matrix of the subgraph.
   */
  getSubgraphDistanceMatrix(vertexIds) {
    const length = vertexIds.length;
    const adja = this.getSubgraphAdjacencyMatrix(vertexIds);
    const dist = Array(length);
    for (let i = 0; i < length; i++) {
      dist[i] = Array(length);
      dist[i].fill(Infinity);
    }
    for (let i = 0; i < length; i++) {
      for (let j = 0; j < length; j++) {
        if (adja[i][j] === 1) {
          dist[i][j] = 1;
        }
      }
    }
    for (let k = 0; k < length; k++) {
      for (let i = 0; i < length; i++) {
        for (let j = 0; j < length; j++) {
          if (dist[i][j] > dist[i][k] + dist[k][j]) {
            dist[i][j] = dist[i][k] + dist[k][j];
          }
        }
      }
    }
    return dist;
  }
  /**
   * Get the adjacency list of the graph.
   *
   * @returns {Array[]} The adjancency list of the graph.
   */
  getAdjacencyList() {
    const length = this.vertices.length;
    const adjacencyList = Array(length);
    for (let i = 0; i < length; i++) {
      adjacencyList[i] = [];
      for (let j = 0; j < length; j++) {
        if (i === j) {
          continue;
        }
        if (this.hasEdge(
          this.vertices[i].id,
          this.vertices[j].id
        )) {
          adjacencyList[i].push(j);
        }
      }
    }
    return adjacencyList;
  }
  /**
   * Get the adjacency list of a subgraph.
   *
   * @param {Number[]} vertexIds An array containing the vertex ids contained within the subgraph.
   * @returns {Array[]} The adjancency list of the subgraph.
   */
  getSubgraphAdjacencyList(vertexIds) {
    const length = vertexIds.length;
    const adjacencyList = Array(length);
    for (let i = 0; i < length; i++) {
      adjacencyList[i] = [];
      for (let j = 0; j < length; j++) {
        if (i === j) {
          continue;
        }
        if (this.hasEdge(vertexIds[i], vertexIds[j])) {
          adjacencyList[i].push(j);
        }
      }
    }
    return adjacencyList;
  }
  /**
   * Returns an array containing the edge ids of bridges. A bridge splits the graph into multiple components when removed.
   *
   * @returns {Number[]} An array containing the edge ids of the bridges.
   */
  getBridges() {
    const length = this.vertices.length;
    const visited = new Array(length);
    const disc = new Array(length);
    const low = new Array(length);
    const parent = new Array(length);
    const adj = this.getAdjacencyList();
    const outBridges = [];
    visited.fill(false);
    parent.fill(null);
    this._time = 0;
    for (let i = 0; i < length; i++) {
      if (!visited[i]) {
        this._bridgeDfs(i, visited, disc, low, parent, adj, outBridges);
      }
    }
    return outBridges;
  }
  /**
   * Traverses the graph in breadth-first order.
   *
   * @param {Number} startVertexId The id of the starting vertex.
   * @param {Function} callback The callback function to be called on every vertex.
   */
  traverseBF(startVertexId, callback) {
    const length = this.vertices.length;
    const visited = new Array(length);
    visited.fill(false);
    const queue = [startVertexId];
    while (queue.length > 0) {
      const u = queue.shift();
      const vertex = this.vertices[u];
      callback(vertex);
      for (let i = 0; i < vertex.neighbours.length; i++) {
        const v = vertex.neighbours[i];
        if (!visited[v]) {
          visited[v] = true;
          queue.push(v);
        }
      }
    }
  }
  /**
   * Get the depth of a subtree in the direction opposite to the vertex specified as the parent vertex.
   *
   * @param {Number} vertexId A vertex id.
   * @param {Number} parentVertexId The id of a neighbouring vertex.
   * @returns {Number} The depth of the sub-tree.
   */
  getTreeDepth(vertexId, parentVertexId) {
    if (vertexId === null || parentVertexId === null) {
      return 0;
    }
    const neighbours = this.vertices[vertexId].getSpanningTreeNeighbours(parentVertexId);
    let max = 0;
    for (let i = 0; i < neighbours.length; i++) {
      const childId = neighbours[i];
      const d = this.getTreeDepth(childId, vertexId);
      if (d > max) {
        max = d;
      }
    }
    return max + 1;
  }
  /**
   * Traverse a sub-tree in the graph.
   *
   * @param {Number} vertexId A vertex id.
   * @param {Number} parentVertexId A neighbouring vertex.
   * @param {Function} callback The callback function that is called with each visited as an argument.
   * @param {Number} [maxDepth=999999] The maximum depth of the recursion.
   * @param {Boolean} [ignoreFirst=false] Whether or not to ignore the starting vertex supplied as vertexId in the callback.
   * @param {Number} [depth=1] The current depth in the tree.
   * @param {Uint8Array} [visited=null] An array holding a flag on whether or not a node has been visited.
   */
  traverseTree(vertexId, parentVertexId, callback, maxDepth = 999999, ignoreFirst = false, depth = 1, visited = null) {
    if (visited === null) {
      visited = new Uint8Array(this.vertices.length);
    }
    if (depth > maxDepth + 1 || visited[vertexId] === 1) {
      return;
    }
    visited[vertexId] = 1;
    const vertex = this.vertices[vertexId];
    const neighbours = vertex.getNeighbours(parentVertexId);
    if (!ignoreFirst || depth > 1) {
      callback(vertex);
    }
    for (let i = 0; i < neighbours.length; i++) {
      this.traverseTree(
        neighbours[i],
        vertexId,
        callback,
        maxDepth,
        ignoreFirst,
        depth + 1,
        visited
      );
    }
  }
  /**
   * Positiones the (sub)graph using Kamada and Kawais algorithm for drawing general undirected graphs. https://pdfs.semanticscholar.org/b8d3/bca50ccc573c5cb99f7d201e8acce6618f04.pdf
   * There are undocumented layout parameters. They are undocumented for a reason, so be very careful.
   *
   * @param {Number[]} vertexIds An array containing vertexIds to be placed using the force based layout.
   * @param {Vector2} center The center of the layout.
   * @param {Number} startVertexId A vertex id. Should be the starting vertex - e.g. the first to be positioned and connected to a previously place vertex.
   * @param {Ring} ring The bridged ring associated with this force-based layout.
   */
  kkLayout(vertexIds, center, startVertexId, ring, bondLength, threshold = 0.1, innerThreshold = 0.1, maxIteration = 2e3, maxInnerIteration = 50, maxEnergy = 1e9) {
    const edgeStrength = bondLength;
    let i = vertexIds.length;
    while (i--) {
      const vertex = this.vertices[vertexIds[i]];
      let j = vertex.neighbours.length;
    }
    const matDist = this.getSubgraphDistanceMatrix(vertexIds);
    const length = vertexIds.length;
    const radius = MathHelper.polyCircumradius(500, length);
    const angle = MathHelper.centralAngle(length);
    let a = 0;
    const arrPositionX = new Float32Array(length);
    const arrPositionY = new Float32Array(length);
    const arrPositioned = Array(length);
    i = length;
    while (i--) {
      const vertex = this.vertices[vertexIds[i]];
      if (!vertex.positioned) {
        arrPositionX[i] = center.x + Math.cos(a) * radius;
        arrPositionY[i] = center.y + Math.sin(a) * radius;
      } else {
        arrPositionX[i] = vertex.position.x;
        arrPositionY[i] = vertex.position.y;
      }
      arrPositioned[i] = vertex.positioned;
      a += angle;
    }
    const matLength = Array(length);
    i = length;
    while (i--) {
      matLength[i] = new Array(length);
      let j = length;
      while (j--) {
        matLength[i][j] = bondLength * matDist[i][j];
      }
    }
    const matStrength = Array(length);
    i = length;
    while (i--) {
      matStrength[i] = Array(length);
      let j = length;
      while (j--) {
        matStrength[i][j] = edgeStrength * Math.pow(matDist[i][j], -2);
      }
    }
    const matEnergy = Array(length);
    const arrEnergySumX = new Float32Array(length);
    const arrEnergySumY = new Float32Array(length);
    i = length;
    while (i--) {
      matEnergy[i] = Array(length);
    }
    i = length;
    let ux, uy, dEx, dEy, vx, vy, denom;
    while (i--) {
      ux = arrPositionX[i];
      uy = arrPositionY[i];
      dEx = 0;
      dEy = 0;
      let j = length;
      while (j--) {
        if (i === j) {
          continue;
        }
        vx = arrPositionX[j];
        vy = arrPositionY[j];
        denom = 1 / Math.sqrt((ux - vx) * (ux - vx) + (uy - vy) * (uy - vy));
        matEnergy[i][j] = [
          matStrength[i][j] * (ux - vx - matLength[i][j] * (ux - vx) * denom),
          matStrength[i][j] * (uy - vy - matLength[i][j] * (uy - vy) * denom)
        ];
        matEnergy[j][i] = matEnergy[i][j];
        dEx += matEnergy[i][j][0];
        dEy += matEnergy[i][j][1];
      }
      arrEnergySumX[i] = dEx;
      arrEnergySumY[i] = dEy;
    }
    const energy = function(index) {
      return [
        arrEnergySumX[index] * arrEnergySumX[index] + arrEnergySumY[index] * arrEnergySumY[index],
        arrEnergySumX[index],
        arrEnergySumY[index]
      ];
    };
    const highestEnergy = function() {
      let maxEnergy2 = 0;
      let maxEnergyId2 = 0;
      let maxDEX = 0;
      let maxDEY = 0;
      i = length;
      while (i--) {
        const [delta2, dEX2, dEY2] = energy(i);
        if (delta2 > maxEnergy2 && arrPositioned[i] === false) {
          maxEnergy2 = delta2;
          maxEnergyId2 = i;
          maxDEX = dEX2;
          maxDEY = dEY2;
        }
      }
      return [maxEnergyId2, maxEnergy2, maxDEX, maxDEY];
    };
    const update = function(index, dEX2, dEY2) {
      let dxx = 0;
      let dyy = 0;
      let dxy = 0;
      let ux2 = arrPositionX[index];
      let uy2 = arrPositionY[index];
      const arrL = matLength[index];
      const arrK = matStrength[index];
      i = length;
      while (i--) {
        if (i === index) {
          continue;
        }
        const vx3 = arrPositionX[i];
        const vy3 = arrPositionY[i];
        const l = arrL[i];
        const k = arrK[i];
        const m = (ux2 - vx3) * (ux2 - vx3);
        const denom3 = 1 / Math.pow(m + (uy2 - vy3) * (uy2 - vy3), 1.5);
        dxx += k * (1 - l * (uy2 - vy3) * (uy2 - vy3) * denom3);
        dyy += k * (1 - l * m * denom3);
        dxy += k * (l * (ux2 - vx3) * (uy2 - vy3) * denom3);
      }
      if (dxx === 0) {
        dxx = 0.1;
      }
      if (dyy === 0) {
        dyy = 0.1;
      }
      if (dxy === 0) {
        dxy = 0.1;
      }
      let dy = dEX2 / dxx + dEY2 / dxy;
      dy /= dxy / dxx - dyy / dxy;
      let dx = -(dxy * dy + dEX2) / dxx;
      arrPositionX[index] += dx;
      arrPositionY[index] += dy;
      const arrE = matEnergy[index];
      dEX2 = 0;
      dEY2 = 0;
      ux2 = arrPositionX[index];
      uy2 = arrPositionY[index];
      let vx2, vy2, prevEx, prevEy, denom2;
      i = length;
      while (i--) {
        if (index === i) {
          continue;
        }
        vx2 = arrPositionX[i];
        vy2 = arrPositionY[i];
        prevEx = arrE[i][0];
        prevEy = arrE[i][1];
        denom2 = 1 / Math.sqrt((ux2 - vx2) * (ux2 - vx2) + (uy2 - vy2) * (uy2 - vy2));
        dx = arrK[i] * (ux2 - vx2 - arrL[i] * (ux2 - vx2) * denom2);
        dy = arrK[i] * (uy2 - vy2 - arrL[i] * (uy2 - vy2) * denom2);
        arrE[i] = [dx, dy];
        dEX2 += dx;
        dEY2 += dy;
        arrEnergySumX[i] += dx - prevEx;
        arrEnergySumY[i] += dy - prevEy;
      }
      arrEnergySumX[index] = dEX2;
      arrEnergySumY[index] = dEY2;
    };
    let maxEnergyId = 0;
    let dEX = 0;
    let dEY = 0;
    let delta = 0;
    let iteration = 0;
    let innerIteration = 0;
    while (maxEnergy > threshold && maxIteration > iteration) {
      iteration++;
      [maxEnergyId, maxEnergy, dEX, dEY] = highestEnergy();
      delta = maxEnergy;
      innerIteration = 0;
      while (delta > innerThreshold && maxInnerIteration > innerIteration) {
        innerIteration++;
        update(maxEnergyId, dEX, dEY);
        [delta, dEX, dEY] = energy(maxEnergyId);
      }
    }
    i = length;
    while (i--) {
      const index = vertexIds[i];
      const vertex = this.vertices[index];
      vertex.position.x = arrPositionX[i];
      vertex.position.y = arrPositionY[i];
      vertex.positioned = true;
      vertex.forcePositioned = true;
    }
  }
  /**
   * PRIVATE FUNCTION used by getBridges().
   */
  _bridgeDfs(u, visited, disc, low, parent, adj, outBridges) {
    visited[u] = true;
    disc[u] = low[u] = ++this._time;
    for (let i = 0; i < adj[u].length; i++) {
      const v = adj[u][i];
      if (!visited[v]) {
        parent[v] = u;
        this._bridgeDfs(v, visited, disc, low, parent, adj, outBridges);
        low[u] = Math.min(low[u], low[v]);
        if (low[v] > disc[u]) {
          outBridges.push([u, v]);
        }
      } else if (v !== parent[u]) {
        low[u] = Math.min(low[u], disc[v]);
      }
    }
  }
  /**
   * Returns the connected components of the graph.
   *
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Set[]} Connected components as sets.
   */
  static getConnectedComponents(adjacencyMatrix) {
    const length = adjacencyMatrix.length;
    const visited = new Array(length);
    const components = [];
    let count = 0;
    visited.fill(false);
    for (let u = 0; u < length; u++) {
      if (!visited[u]) {
        const component = [];
        visited[u] = true;
        component.push(u);
        count++;
        _Graph._ccGetDfs(u, visited, adjacencyMatrix, component);
        if (component.length > 1) {
          components.push(component);
        }
      }
    }
    return components;
  }
  /**
   * Returns the number of connected components for the graph.
   *
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Number} The number of connected components of the supplied graph.
   */
  static getConnectedComponentCount(adjacencyMatrix) {
    const length = adjacencyMatrix.length;
    const visited = new Array(length);
    let count = 0;
    visited.fill(false);
    for (let u = 0; u < length; u++) {
      if (!visited[u]) {
        visited[u] = true;
        count++;
        _Graph._ccCountDfs(u, visited, adjacencyMatrix);
      }
    }
    return count;
  }
  /**
   * PRIVATE FUNCTION used by getConnectedComponentCount().
   */
  static _ccCountDfs(u, visited, adjacencyMatrix) {
    for (let v = 0; v < adjacencyMatrix[u].length; v++) {
      const c = adjacencyMatrix[u][v];
      if (!c || visited[v] || u === v) {
        continue;
      }
      visited[v] = true;
      _Graph._ccCountDfs(v, visited, adjacencyMatrix);
    }
  }
  /**
   * PRIVATE FUNCTION used by getConnectedComponents().
   */
  static _ccGetDfs(u, visited, adjacencyMatrix, component) {
    for (let v = 0; v < adjacencyMatrix[u].length; v++) {
      const c = adjacencyMatrix[u][v];
      if (!c || visited[v] || u === v) {
        continue;
      }
      visited[v] = true;
      component.push(v);
      _Graph._ccGetDfs(v, visited, adjacencyMatrix, component);
    }
  }
};

// src/SSSR.ts
var SSSR = class _SSSR {
  /**
   * Returns an array containing arrays, each representing a ring from the smallest set of smallest rings in the graph.
   *
   * @param {Graph} graph A Graph object.
   * @param {Boolean} [experimental=false] Whether or not to use experimental SSSR.
   * @returns {Array[]} An array containing arrays, each representing a ring from the smallest set of smallest rings in the group.
   */
  static getRings(graph, experimental = false) {
    const adjacencyMatrix = graph.getComponentsAdjacencyMatrix();
    if (adjacencyMatrix.length === 0) {
      return null;
    }
    const connectedComponents = Graph.getConnectedComponents(adjacencyMatrix);
    const rings = [];
    for (let i = 0; i < connectedComponents.length; i++) {
      const connectedComponent = connectedComponents[i];
      const ccAdjacencyMatrix = graph.getSubgraphAdjacencyMatrix([
        ...connectedComponent
      ]);
      const arrBondCount = new Uint16Array(ccAdjacencyMatrix.length);
      const arrRingCount = new Uint16Array(ccAdjacencyMatrix.length);
      for (let j = 0; j < ccAdjacencyMatrix.length; j++) {
        arrRingCount[j] = 0;
        arrBondCount[j] = 0;
        for (let k = 0; k < ccAdjacencyMatrix[j].length; k++) {
          arrBondCount[j] += ccAdjacencyMatrix[j][k];
        }
      }
      let nEdges = 0;
      for (let j = 0; j < ccAdjacencyMatrix.length; j++) {
        for (let k = j + 1; k < ccAdjacencyMatrix.length; k++) {
          nEdges += ccAdjacencyMatrix[j][k];
        }
      }
      let nSssr = nEdges - ccAdjacencyMatrix.length + 1;
      let allThree = true;
      for (let j = 0; j < arrBondCount.length; j++) {
        if (arrBondCount[j] !== 3) {
          allThree = false;
        }
      }
      if (allThree) {
        nSssr = 2 + nEdges - ccAdjacencyMatrix.length;
      }
      if (nSssr === 1) {
        rings.push([...connectedComponent]);
        continue;
      }
      if (experimental) {
        nSssr = 999;
      }
      const { d, pe, pe_prime } = _SSSR.getPathIncludedDistanceMatrices(ccAdjacencyMatrix);
      const c = _SSSR.getRingCandidates(d, pe, pe_prime);
      const sssr = _SSSR.getSSSR(
        c,
        d,
        ccAdjacencyMatrix,
        pe,
        pe_prime,
        arrBondCount,
        arrRingCount,
        nSssr
      );
      for (let j = 0; j < sssr.length; j++) {
        const ring = Array(sssr[j].size);
        let index = 0;
        for (const val of sssr[j]) {
          ring[index++] = connectedComponent[val];
        }
        rings.push(ring);
      }
    }
    return rings;
  }
  /**
   * Creates a printable string from a matrix (2D array).
   *
   * @param {Array[]} matrix A 2D array.
   * @returns {String} A string representing the matrix.
   */
  static matrixToString(matrix) {
    let str = "";
    for (let i = 0; i < matrix.length; i++) {
      for (let j = 0; j < matrix[i].length; j++) {
        str += matrix[i][j] + " ";
      }
      str += "\n";
    }
    return str;
  }
  /**
   * Returnes the two path-included distance matrices used to find the sssr.
   *
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Object} The path-included distance matrices. { p1, p2 }
   */
  static getPathIncludedDistanceMatrices(adjacencyMatrix) {
    const length = adjacencyMatrix.length;
    const d = Array(length);
    const pe = Array(length);
    const pe_prime = Array(length);
    let l = 0;
    let m = 0;
    let n = 0;
    let i = length;
    while (i--) {
      d[i] = Array(length);
      pe[i] = Array(length);
      pe_prime[i] = Array(length);
      let j = length;
      while (j--) {
        d[i][j] = i === j || adjacencyMatrix[i][j] === 1 ? adjacencyMatrix[i][j] : Number.POSITIVE_INFINITY;
        if (d[i][j] === 1) {
          pe[i][j] = [[[i, j]]];
        } else {
          pe[i][j] = [];
        }
        pe_prime[i][j] = [];
      }
    }
    let k = length;
    while (k--) {
      i = length;
      while (i--) {
        let j = length;
        while (j--) {
          const previousPathLength = d[i][j];
          const newPathLength = d[i][k] + d[k][j];
          if (previousPathLength > newPathLength) {
            if (previousPathLength === newPathLength + 1) {
              pe_prime[i][j] = [pe[i][j].length];
              l = pe[i][j].length;
              while (l--) {
                pe_prime[i][j][l] = [pe[i][j][l].length];
                m = pe[i][j][l].length;
                while (m--) {
                  pe_prime[i][j][l][m] = [pe[i][j][l][m].length];
                  n = pe[i][j][l][m].length;
                  while (n--) {
                    pe_prime[i][j][l][m][n] = [
                      pe[i][j][l][m][0],
                      pe[i][j][l][m][1]
                    ];
                  }
                }
              }
            } else {
              pe_prime[i][j] = [];
            }
            d[i][j] = newPathLength;
            pe[i][j] = [[]];
            l = pe[i][k][0].length;
            while (l--) {
              pe[i][j][0].push(pe[i][k][0][l]);
            }
            l = pe[k][j][0].length;
            while (l--) {
              pe[i][j][0].push(pe[k][j][0][l]);
            }
          } else if (previousPathLength === newPathLength) {
            if (pe[i][k].length && pe[k][j].length) {
              if (pe[i][j].length) {
                const tmp = [];
                l = pe[i][k][0].length;
                while (l--) {
                  tmp.push(pe[i][k][0][l]);
                }
                l = pe[k][j][0].length;
                while (l--) {
                  tmp.push(pe[k][j][0][l]);
                }
                pe[i][j].push(tmp);
              } else {
                const tmp = [];
                l = pe[i][k][0].length;
                while (l--) {
                  tmp.push(pe[i][k][0][l]);
                }
                l = pe[k][j][0].length;
                while (l--) {
                  tmp.push(pe[k][j][0][l]);
                }
                pe[i][j][0] = tmp;
              }
            }
          } else if (previousPathLength === newPathLength - 1) {
            if (pe_prime[i][j].length) {
              const tmp = [];
              l = pe[i][k][0].length;
              while (l--) {
                tmp.push(pe[i][k][0][l]);
              }
              l = pe[k][j][0].length;
              while (l--) {
                tmp.push(pe[k][j][0][l]);
              }
              pe_prime[i][j].push(tmp);
            } else {
              const tmp = [];
              l = pe[i][k][0].length;
              while (l--) {
                tmp.push(pe[i][k][0][l]);
              }
              l = pe[k][j][0].length;
              while (l--) {
                tmp.push(pe[k][j][0][l]);
              }
              pe_prime[i][j][0] = tmp;
            }
          }
        }
      }
    }
    return {
      d,
      pe,
      pe_prime
    };
  }
  /**
   * Get the ring candidates from the path-included distance matrices.
   *
   * @param {Array[]} d The distance matrix.
   * @param {Array[]} pe A matrix containing the shortest paths.
   * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.
   * @returns {Array[]} The ring candidates.
   */
  static getRingCandidates(d, pe, pe_prime) {
    const length = d.length;
    const candidates = [];
    let c = 0;
    for (let i = 0; i < length; i++) {
      for (let j = 0; j < length; j++) {
        if (d[i][j] === 0 || pe[i][j].length === 1 && pe_prime[i][j] === 0) {
          continue;
        } else {
          if (pe_prime[i][j].length !== 0) {
            c = 2 * (d[i][j] + 0.5);
          } else {
            c = 2 * d[i][j];
          }
          if (c !== Infinity) {
            candidates.push([c, pe[i][j], pe_prime[i][j]]);
          }
        }
      }
    }
    candidates.sort(function(a, b) {
      return a[0] - b[0];
    });
    return candidates;
  }
  /**
   * Searches the candidates for the smallest set of smallest rings.
   *
   * @param {Array[]} c The candidates.
   * @param {Array[]} d The distance matrix.
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @param {Array[]} pe A matrix containing the shortest paths.
   * @param {Array[]} pe_prime A matrix containing the shortest paths + one vertex.
   * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.
   * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.
   * @param {Number} nsssr The theoretical number of rings in the graph.
   * @returns {Set[]} The smallest set of smallest rings.
   */
  static getSSSR(c, d, adjacencyMatrix, pe, pe_prime, arrBondCount, arrRingCount, nsssr) {
    const cSssr = [];
    let allBonds = [];
    for (let i = 0; i < c.length; i++) {
      if (c[i][0] % 2 !== 0) {
        for (let j = 0; j < c[i][2].length; j++) {
          const bonds = c[i][1][0].concat(c[i][2][j]);
          for (let k = 0; k < bonds.length; k++) {
            if (bonds[k][0].constructor === Array) {
              bonds[k] = bonds[k][0];
            }
          }
          const atoms = _SSSR.bondsToAtoms(bonds);
          if (_SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !_SSSR.pathSetsContain(
            cSssr,
            atoms,
            bonds,
            allBonds,
            arrBondCount,
            arrRingCount
          )) {
            cSssr.push(atoms);
            allBonds = allBonds.concat(bonds);
          }
          if (cSssr.length > nsssr) {
            return cSssr;
          }
        }
      } else {
        for (let j = 0; j < c[i][1].length - 1; j++) {
          const bonds = c[i][1][j].concat(c[i][1][j + 1]);
          for (let k = 0; k < bonds.length; k++) {
            if (bonds[k][0].constructor === Array) {
              bonds[k] = bonds[k][0];
            }
          }
          const atoms = _SSSR.bondsToAtoms(bonds);
          if (_SSSR.getBondCount(atoms, adjacencyMatrix) === atoms.size && !_SSSR.pathSetsContain(
            cSssr,
            atoms,
            bonds,
            allBonds,
            arrBondCount,
            arrRingCount
          )) {
            cSssr.push(atoms);
            allBonds = allBonds.concat(bonds);
          }
          if (cSssr.length > nsssr) {
            return cSssr;
          }
        }
      }
    }
    return cSssr;
  }
  /**
   * Returns the number of edges in a graph defined by an adjacency matrix.
   *
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Number} The number of edges in the graph defined by the adjacency matrix.
   */
  static getEdgeCount(adjacencyMatrix) {
    let edgeCount = 0;
    const length = adjacencyMatrix.length;
    let i = length - 1;
    while (i--) {
      let j = length;
      while (j--) {
        if (adjacencyMatrix[i][j] === 1) {
          edgeCount++;
        }
      }
    }
    return edgeCount;
  }
  /**
   * Returns an edge list constructed form an adjacency matrix.
   *
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Array[]} An edge list. E.g. [ [ 0, 1 ], ..., [ 16, 2 ] ]
   */
  static getEdgeList(adjacencyMatrix) {
    const length = adjacencyMatrix.length;
    const edgeList = [];
    let i = length - 1;
    while (i--) {
      let j = length;
      while (j--) {
        if (adjacencyMatrix[i][j] === 1) {
          edgeList.push([i, j]);
        }
      }
    }
    return edgeList;
  }
  /**
   * Return a set of vertex indices contained in an array of bonds.
   *
   * @param {Array} bonds An array of bonds. A bond is defined as [ sourceVertexId, targetVertexId ].
   * @returns {Set<Number>} An array of vertices.
   */
  static bondsToAtoms(bonds) {
    const atoms = /* @__PURE__ */ new Set();
    let i = bonds.length;
    while (i--) {
      atoms.add(bonds[i][0]);
      atoms.add(bonds[i][1]);
    }
    return atoms;
  }
  /**
   * Returns the number of bonds within a set of atoms.
   *
   * @param {Set<Number>} atoms An array of atom ids.
   * @param {Array[]} adjacencyMatrix An adjacency matrix.
   * @returns {Number} The number of bonds in a set of atoms.
   */
  static getBondCount(atoms, adjacencyMatrix) {
    let count = 0;
    for (const u of atoms) {
      for (const v of atoms) {
        if (u === v) {
          continue;
        }
        count += adjacencyMatrix[u][v];
      }
    }
    return count / 2;
  }
  /**
   * Checks whether or not a given path already exists in an array of paths.
   *
   * @param {Set[]} pathSets An array of sets each representing a path.
   * @param {Set<Number>} pathSet A set representing a path.
   * @param {Array[]} bonds The bonds associated with the current path.
   * @param {Array[]} allBonds All bonds currently associated with rings in the SSSR set.
   * @param {Uint16Array} arrBondCount A matrix containing the bond count of each vertex.
   * @param {Uint16Array} arrRingCount A matrix containing the number of rings associated with each vertex.
   * @returns {Boolean} A boolean indicating whether or not a give path is contained within a set.
   */
  static pathSetsContain(pathSets, pathSet, bonds, allBonds, arrBondCount, arrRingCount) {
    let i = pathSets.length;
    while (i--) {
      if (_SSSR.isSupersetOf(pathSet, pathSets[i])) {
        return true;
      }
      if (pathSets[i].size !== pathSet.size) {
        continue;
      }
      if (_SSSR.areSetsEqual(pathSets[i], pathSet)) {
        return true;
      }
    }
    let count = 0;
    let allContained = false;
    i = bonds.length;
    while (i--) {
      let j = allBonds.length;
      while (j--) {
        if (bonds[i][0] === allBonds[j][0] && bonds[i][1] === allBonds[j][1] || bonds[i][1] === allBonds[j][0] && bonds[i][0] === allBonds[j][1]) {
          count++;
        }
        if (count === bonds.length) {
          allContained = true;
        }
      }
    }
    let specialCase = false;
    if (allContained) {
      for (const element of pathSet) {
        if (arrRingCount[element] < arrBondCount[element]) {
          specialCase = true;
          break;
        }
      }
    }
    if (allContained && !specialCase) {
      return true;
    }
    for (const element of pathSet) {
      arrRingCount[element]++;
    }
    return false;
  }
  /**
   * Checks whether or not two sets are equal (contain the same elements).
   *
   * @param {Set<Number>} setA A set.
   * @param {Set<Number>} setB A set.
   * @returns {Boolean} A boolean indicating whether or not the two sets are equal.
   */
  static areSetsEqual(setA, setB) {
    if (setA.size !== setB.size) {
      return false;
    }
    for (const element of setA) {
      if (!setB.has(element)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks whether or not a set (setA) is a superset of another set (setB).
   *
   * @param {Set<Number>} setA A set.
   * @param {Set<Number>} setB A set.
   * @returns {Boolean} A boolean indicating whether or not setB is a superset of setA.
   */
  static isSupersetOf(setA, setB) {
    for (const element of setB) {
      if (!setA.has(element)) {
        return false;
      }
    }
    return true;
  }
};

// src/ThemeManager.ts
var ThemeManager = class {
  colors;
  theme;
  constructor(colors, theme) {
    this.colors = colors;
    this.theme = this.colors[theme];
  }
  /**
   * Returns the hex code of a color associated with a key from the current theme.
   *
   * @param {String} key The color key in the theme (e.g. C, N, BACKGROUND, ...).
   * @returns {String} A color hex value.
   */
  getColor(key) {
    if (key) {
      key = key.toUpperCase();
      if (key in this.theme) {
        return this.theme[key];
      }
    }
    return this.theme["C"];
  }
  /**
   * Sets the theme to the specified string if it exists. If it does not, this
   * does nothing.
   *
   * @param {String} theme the name of the theme to switch to
   */
  setTheme(theme) {
    if (this.colors.hasOwnProperty(theme)) {
      this.theme = this.colors[theme];
    }
  }
};

// src/Options.ts
var Options = class {
  /**
   * A helper method to extend the default options with user supplied ones.
   */
  static extend() {
    const that = this;
    const extended = {};
    let deep = false;
    let i = 0;
    const length = arguments.length;
    if (Object.prototype.toString.call(arguments[0]) === "[object Boolean]") {
      deep = arguments[0];
      i++;
    }
    const merge = function(obj) {
      for (const prop in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {
          if (deep && Object.prototype.toString.call(obj[prop]) === "[object Object]") {
            extended[prop] = that.extend(true, extended[prop], obj[prop]);
          } else {
            extended[prop] = obj[prop];
          }
        }
      }
    };
    for (; i < length; i++) {
      const obj = arguments[i];
      merge(obj);
    }
    return extended;
  }
};

// src/DrawerBase.ts
var DrawerBase = class {
  graph;
  doubleBondConfigCount;
  doubleBondConfig;
  ringIdCounter;
  ringConnectionIdCounter;
  canvasWrapper;
  totalOverlapScore;
  defaultOptions;
  opts;
  theme;
  infoOnly;
  themeManager;
  rings;
  ringConnections;
  originalRings;
  bridgedRing;
  data;
  originalRingConnections;
  highlight_atoms;
  /**
   * The constructor for the class SmilesDrawer.
   *
   * @param {Object} options An object containing custom values for different options. It is merged with the default options.
   */
  constructor(options) {
    this.graph = null;
    this.doubleBondConfigCount = 0;
    this.doubleBondConfig = null;
    this.ringIdCounter = 0;
    this.ringConnectionIdCounter = 0;
    this.canvasWrapper = null;
    this.totalOverlapScore = 0;
    this.defaultOptions = {
      width: 500,
      height: 500,
      scale: 0,
      bondThickness: 1,
      bondLength: 30,
      shortBondLength: 0.8,
      bondSpacing: 0.17 * 30,
      atomVisualization: "default",
      isomeric: true,
      debug: false,
      terminalCarbons: false,
      explicitHydrogens: true,
      overlapSensitivity: 0.42,
      overlapResolutionIterations: 1,
      compactDrawing: true,
      fontFamily: "Arial, Helvetica, sans-serif",
      fontSizeLarge: 11,
      fontSizeSmall: 3,
      padding: 10,
      experimentalSSSR: false,
      kkThreshold: 0.1,
      kkInnerThreshold: 0.1,
      kkMaxIteration: 2e4,
      kkMaxInnerIteration: 50,
      kkMaxEnergy: 1e9,
      themes: {
        dark: {
          C: "#fff",
          O: "#e74c3c",
          N: "#3498db",
          F: "#27ae60",
          CL: "#16a085",
          BR: "#d35400",
          I: "#8e44ad",
          P: "#d35400",
          S: "#f1c40f",
          B: "#e67e22",
          SI: "#e67e22",
          H: "#aaa",
          BACKGROUND: "#141414"
        },
        light: {
          C: "#222",
          O: "#e74c3c",
          N: "#3498db",
          F: "#27ae60",
          CL: "#16a085",
          BR: "#d35400",
          I: "#8e44ad",
          P: "#d35400",
          S: "#f1c40f",
          B: "#e67e22",
          SI: "#e67e22",
          H: "#666",
          BACKGROUND: "#fff"
        },
        oldschool: {
          C: "#000",
          O: "#000",
          N: "#000",
          F: "#000",
          CL: "#000",
          BR: "#000",
          I: "#000",
          P: "#000",
          S: "#000",
          B: "#000",
          SI: "#000",
          H: "#000",
          BACKGROUND: "#fff"
        },
        solarized: {
          C: "#586e75",
          O: "#dc322f",
          N: "#268bd2",
          F: "#859900",
          CL: "#16a085",
          BR: "#cb4b16",
          I: "#6c71c4",
          P: "#d33682",
          S: "#b58900",
          B: "#2aa198",
          SI: "#2aa198",
          H: "#657b83",
          BACKGROUND: "#fff"
        },
        "solarized-dark": {
          C: "#93a1a1",
          O: "#dc322f",
          N: "#268bd2",
          F: "#859900",
          CL: "#16a085",
          BR: "#cb4b16",
          I: "#6c71c4",
          P: "#d33682",
          S: "#b58900",
          B: "#2aa198",
          SI: "#2aa198",
          H: "#839496",
          BACKGROUND: "#fff"
        },
        matrix: {
          C: "#678c61",
          O: "#2fc079",
          N: "#4f7e7e",
          F: "#90d762",
          CL: "#82d967",
          BR: "#23755a",
          I: "#409931",
          P: "#c1ff8a",
          S: "#faff00",
          B: "#50b45a",
          SI: "#409931",
          H: "#426644",
          BACKGROUND: "#fff"
        },
        github: {
          C: "#24292f",
          O: "#cf222e",
          N: "#0969da",
          F: "#2da44e",
          CL: "#6fdd8b",
          BR: "#bc4c00",
          I: "#8250df",
          P: "#bf3989",
          S: "#d4a72c",
          B: "#fb8f44",
          SI: "#bc4c00",
          H: "#57606a",
          BACKGROUND: "#fff"
        },
        carbon: {
          C: "#161616",
          O: "#da1e28",
          N: "#0f62fe",
          F: "#198038",
          CL: "#007d79",
          BR: "#fa4d56",
          I: "#8a3ffc",
          P: "#ff832b",
          S: "#f1c21b",
          B: "#8a3800",
          SI: "#e67e22",
          H: "#525252",
          BACKGROUND: "#fff"
        },
        cyberpunk: {
          C: "#ea00d9",
          O: "#ff3131",
          N: "#0abdc6",
          F: "#00ff9f",
          CL: "#00fe00",
          BR: "#fe9f20",
          I: "#ff00ff",
          P: "#fe7f00",
          S: "#fcee0c",
          B: "#ff00ff",
          SI: "#ffffff",
          H: "#913cb1",
          BACKGROUND: "#fff"
        },
        gruvbox: {
          C: "#665c54",
          O: "#cc241d",
          N: "#458588",
          F: "#98971a",
          CL: "#79740e",
          BR: "#d65d0e",
          I: "#b16286",
          P: "#af3a03",
          S: "#d79921",
          B: "#689d6a",
          SI: "#427b58",
          H: "#7c6f64",
          BACKGROUND: "#fbf1c7"
        },
        "gruvbox-dark": {
          C: "#ebdbb2",
          O: "#cc241d",
          N: "#458588",
          F: "#98971a",
          CL: "#b8bb26",
          BR: "#d65d0e",
          I: "#b16286",
          P: "#fe8019",
          S: "#d79921",
          B: "#8ec07c",
          SI: "#83a598",
          H: "#bdae93",
          BACKGROUND: "#282828"
        },
        custom: {
          C: "#222",
          O: "#e74c3c",
          N: "#3498db",
          F: "#27ae60",
          CL: "#16a085",
          BR: "#d35400",
          I: "#8e44ad",
          P: "#d35400",
          S: "#f1c40f",
          B: "#e67e22",
          SI: "#e67e22",
          H: "#666",
          BACKGROUND: "#fff"
        }
      }
    };
    this.opts = Options.extend(true, this.defaultOptions, options);
    this.opts.halfBondSpacing = this.opts.bondSpacing / 2;
    this.opts.bondLengthSq = this.opts.bondLength * this.opts.bondLength;
    this.opts.halfFontSizeLarge = this.opts.fontSizeLarge / 2;
    this.opts.quarterFontSizeLarge = this.opts.fontSizeLarge / 4;
    this.opts.fifthFontSizeSmall = this.opts.fontSizeSmall / 5;
    this.theme = this.opts.themes.dark;
  }
  /**
   * Draws the parsed smiles data to a canvas element.
   *
   * @param {Object} data The tree returned by the smiles parser.
   * @param {(String|HTMLCanvasElement)} target The id of the HTML canvas element the structure is drawn to - or the element itself.
   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
   */
  draw(data, target, themeName = "light", infoOnly = false) {
    this.initDraw(data, themeName, infoOnly);
    if (!this.infoOnly) {
      this.themeManager = new ThemeManager(this.opts.themes, themeName);
      this.canvasWrapper = new CanvasWrapper(
        target,
        this.themeManager,
        this.opts
      );
    }
    if (!infoOnly) {
      this.processGraph();
      this.canvasWrapper.scale(this.graph.vertices);
      this.drawEdges(this.opts.debug);
      this.drawVertices(this.opts.debug);
      this.canvasWrapper.reset();
      if (this.opts.debug) {
        console.log(this.graph);
        console.log(this.rings);
        console.log(this.ringConnections);
      }
    }
  }
  /**
   * Returns the number of rings this edge is a part of.
   *
   * @param {Number} edgeId The id of an edge.
   * @returns {Number} The number of rings the provided edge is part of.
   */
  edgeRingCount(edgeId) {
    const edge = this.graph.edges[edgeId];
    const a = this.graph.vertices[edge.sourceId];
    const b = this.graph.vertices[edge.targetId];
    return Math.min(a.value.rings.length, b.value.rings.length);
  }
  /**
   * Returns an array containing the bridged rings associated with this  molecule.
   *
   * @returns {Ring[]} An array containing all bridged rings associated with this molecule.
   */
  getBridgedRings() {
    const bridgedRings = [];
    for (let i = 0; i < this.rings.length; i++) {
      if (this.rings[i].isBridged) {
        bridgedRings.push(this.rings[i]);
      }
    }
    return bridgedRings;
  }
  /**
   * Returns an array containing all fused rings associated with this molecule.
   *
   * @returns {Ring[]} An array containing all fused rings associated with this molecule.
   */
  getFusedRings() {
    const fusedRings = [];
    for (let i = 0; i < this.rings.length; i++) {
      if (this.rings[i].isFused) {
        fusedRings.push(this.rings[i]);
      }
    }
    return fusedRings;
  }
  /**
   * Returns an array containing all spiros associated with this molecule.
   *
   * @returns {Ring[]} An array containing all spiros associated with this molecule.
   */
  getSpiros() {
    const spiros = [];
    for (let i = 0; i < this.rings.length; i++) {
      if (this.rings[i].isSpiro) {
        spiros.push(this.rings[i]);
      }
    }
    return spiros;
  }
  /**
   * Returns a string containing a semicolon and new-line separated list of ring properties: Id; Members Count; Neighbours Count; IsSpiro; IsFused; IsBridged; Ring Count (subrings of bridged rings)
   *
   * @returns {String} A string as described in the method description.
   */
  printRingInfo() {
    let result = "";
    for (let i = 0; i < this.rings.length; i++) {
      const ring = this.rings[i];
      result += ring.id + ";";
      result += ring.members.length + ";";
      result += ring.neighbours.length + ";";
      result += ring.isSpiro ? "true;" : "false;";
      result += ring.isFused ? "true;" : "false;";
      result += ring.isBridged ? "true;" : "false;";
      result += ring.rings.length + ";";
      result += "\n";
    }
    return result;
  }
  /**
   * Rotates the drawing to make the widest dimension horizontal.
   */
  rotateDrawing() {
    let a = 0;
    let b = 0;
    let maxDist = 0;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertexA = this.graph.vertices[i];
      if (!vertexA.value.isDrawn) {
        continue;
      }
      for (let j = i + 1; j < this.graph.vertices.length; j++) {
        const vertexB = this.graph.vertices[j];
        if (!vertexB.value.isDrawn) {
          continue;
        }
        const dist = vertexA.position.distanceSq(vertexB.position);
        if (dist > maxDist) {
          maxDist = dist;
          a = i;
          b = j;
        }
      }
    }
    let angle = -Vector2.subtract(
      this.graph.vertices[a].position,
      this.graph.vertices[b].position
    ).angle();
    if (!isNaN(angle)) {
      const remainder = angle % 0.523599;
      if (remainder < 0.2617995) {
        angle = angle - remainder;
      } else {
        angle += 0.523599 - remainder;
      }
      for (let i = 0; i < this.graph.vertices.length; i++) {
        if (i === b) {
          continue;
        }
        this.graph.vertices[i].position.rotateAround(
          angle,
          this.graph.vertices[b].position
        );
      }
      for (let i = 0; i < this.rings.length; i++) {
        this.rings[i].center.rotateAround(
          angle,
          this.graph.vertices[b].position
        );
      }
    }
  }
  /**
   * Returns the total overlap score of the current molecule.
   *
   * @returns {Number} The overlap score.
   */
  getTotalOverlapScore() {
    return this.totalOverlapScore;
  }
  /**
   * Returns the ring count of the current molecule.
   *
   * @returns {Number} The ring count.
   */
  getRingCount() {
    return this.rings.length;
  }
  /**
   * Checks whether or not the current molecule  a bridged ring.
   *
   * @returns {Boolean} A boolean indicating whether or not the current molecule  a bridged ring.
   */
  hasBridgedRing() {
    return this.bridgedRing;
  }
  /**
   * Returns the number of heavy atoms (non-hydrogen) in the current molecule.
   *
   * @returns {Number} The heavy atom count.
   */
  getHeavyAtomCount() {
    let hac = 0;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      if (this.graph.vertices[i].value.element !== "H") {
        hac++;
      }
    }
    return hac;
  }
  /**
   * Returns the molecular formula of the loaded molecule as a string.
   *
   * @returns {String} The molecular formula.
   */
  getMolecularFormula(data = null) {
    let molecularFormula = "";
    const counts = /* @__PURE__ */ new Map();
    const graph = data === null ? this.graph : new Graph(data, this.opts.isomeric);
    for (let i = 0; i < graph.vertices.length; i++) {
      const atom = graph.vertices[i].value;
      if (counts.has(atom.element)) {
        counts.set(atom.element, counts.get(atom.element) + 1);
      } else {
        counts.set(atom.element, 1);
      }
      if (atom.bracket && !atom.bracket.chirality) {
        if (counts.has("H")) {
          counts.set("H", counts.get("H") + atom.bracket.hcount);
        } else {
          counts.set("H", atom.bracket.hcount);
        }
      }
      if (!atom.bracket) {
        let nHydrogens = Atom.maxBonds[atom.element] - atom.bondCount;
        if (atom.isPartOfAromaticRing) {
          nHydrogens--;
        }
        if (counts.has("H")) {
          counts.set("H", counts.get("H") + nHydrogens);
        } else {
          counts.set("H", nHydrogens);
        }
      }
    }
    if (counts.has("C")) {
      const count = counts.get("C");
      molecularFormula += "C" + (count > 1 ? count : "");
      counts.delete("C");
    }
    if (counts.has("H")) {
      const count = counts.get("H");
      molecularFormula += "H" + (count > 1 ? count : "");
      counts.delete("H");
    }
    const elements = Object.keys(Atom.atomicNumbers).sort();
    elements.map((e) => {
      if (counts.has(e)) {
        const count = counts.get(e);
        molecularFormula += e + (count > 1 ? count : "");
      }
    });
    return molecularFormula;
  }
  /**
   * Returns the type of the ringbond (e.g. '=' for a double bond). The ringbond represents the break in a ring introduced when creating the MST. If the two vertices supplied as arguments are not part of a common ringbond, the method returns null.
   *
   * @param {Vertex} vertexA A vertex.
   * @param {Vertex} vertexB A vertex.
   * @returns {(String|null)} Returns the ringbond type or null, if the two supplied vertices are not connected by a ringbond.
   */
  getRingbondType(vertexA, vertexB) {
    if (vertexA.value.getRingbondCount() < 1 || vertexB.value.getRingbondCount() < 1) {
      return null;
    }
    for (let i = 0; i < vertexA.value.ringbonds.length; i++) {
      for (let j = 0; j < vertexB.value.ringbonds.length; j++) {
        if (vertexA.value.ringbonds[i].id === vertexB.value.ringbonds[j].id) {
          if (vertexA.value.ringbonds[i].bondType === "-") {
            return vertexB.value.ringbonds[j].bond;
          } else {
            return vertexA.value.ringbonds[i].bond;
          }
        }
      }
    }
    return null;
  }
  initDraw(data, themeName, infoOnly, highlight_atoms) {
    this.data = data;
    this.infoOnly = infoOnly;
    this.ringIdCounter = 0;
    this.ringConnectionIdCounter = 0;
    this.graph = new Graph(data, this.opts.isomeric);
    this.rings = [];
    this.ringConnections = [];
    this.originalRings = [];
    this.originalRingConnections = [];
    this.bridgedRing = false;
    this.doubleBondConfigCount = null;
    this.doubleBondConfig = null;
    this.highlight_atoms = highlight_atoms;
    this.initRings();
    this.initHydrogens();
  }
  processGraph() {
    this.position();
    this.restoreRingInformation();
    this.resolvePrimaryOverlaps();
    let overlapScore = this.getOverlapScore();
    this.totalOverlapScore = this.getOverlapScore().total;
    for (let o = 0; o < this.opts.overlapResolutionIterations; o++) {
      for (let i = 0; i < this.graph.edges.length; i++) {
        const edge = this.graph.edges[i];
        if (this.isEdgeRotatable(edge)) {
          const subTreeDepthA = this.graph.getTreeDepth(
            edge.sourceId,
            edge.targetId
          );
          const subTreeDepthB = this.graph.getTreeDepth(
            edge.targetId,
            edge.sourceId
          );
          let a = edge.targetId;
          let b = edge.sourceId;
          if (subTreeDepthA > subTreeDepthB) {
            a = edge.sourceId;
            b = edge.targetId;
          }
          const subTreeOverlap = this.getSubtreeOverlapScore(
            b,
            a,
            overlapScore.vertexScores
          );
          if (subTreeOverlap.value > this.opts.overlapSensitivity) {
            const vertexA = this.graph.vertices[a];
            const vertexB = this.graph.vertices[b];
            const neighboursB = vertexB.getNeighbours(a);
            if (neighboursB.length === 1) {
              const neighbour = this.graph.vertices[neighboursB[0]];
              const angle = neighbour.position.getRotateAwayFromAngle(
                vertexA.position,
                vertexB.position,
                MathHelper.toRad(120)
              );
              this.rotateSubtree(
                neighbour.id,
                vertexB.id,
                angle,
                vertexB.position
              );
              const newTotalOverlapScore = this.getOverlapScore().total;
              if (newTotalOverlapScore > this.totalOverlapScore) {
                this.rotateSubtree(
                  neighbour.id,
                  vertexB.id,
                  -angle,
                  vertexB.position
                );
              } else {
                this.totalOverlapScore = newTotalOverlapScore;
              }
            } else if (neighboursB.length === 2) {
              if (vertexB.value.rings.length !== 0 && vertexA.value.rings.length !== 0) {
                continue;
              }
              const neighbourA = this.graph.vertices[neighboursB[0]];
              const neighbourB = this.graph.vertices[neighboursB[1]];
              if (neighbourA.value.rings.length === 1 && neighbourB.value.rings.length === 1) {
                if (neighbourA.value.rings[0] !== neighbourB.value.rings[0]) {
                  continue;
                }
              } else if (neighbourA.value.rings.length !== 0 || neighbourB.value.rings.length !== 0) {
                continue;
              } else {
                const angleA = neighbourA.position.getRotateAwayFromAngle(
                  vertexA.position,
                  vertexB.position,
                  MathHelper.toRad(120)
                );
                const angleB = neighbourB.position.getRotateAwayFromAngle(
                  vertexA.position,
                  vertexB.position,
                  MathHelper.toRad(120)
                );
                this.rotateSubtree(
                  neighbourA.id,
                  vertexB.id,
                  angleA,
                  vertexB.position
                );
                this.rotateSubtree(
                  neighbourB.id,
                  vertexB.id,
                  angleB,
                  vertexB.position
                );
                const newTotalOverlapScore = this.getOverlapScore().total;
                if (newTotalOverlapScore > this.totalOverlapScore) {
                  this.rotateSubtree(
                    neighbourA.id,
                    vertexB.id,
                    -angleA,
                    vertexB.position
                  );
                  this.rotateSubtree(
                    neighbourB.id,
                    vertexB.id,
                    -angleB,
                    vertexB.position
                  );
                } else {
                  this.totalOverlapScore = newTotalOverlapScore;
                }
              }
            }
            overlapScore = this.getOverlapScore();
          }
        }
      }
    }
    this.resolveSecondaryOverlaps(overlapScore.scores);
    if (this.opts.isomeric) {
      this.annotateStereochemistry();
    }
    if (this.opts.compactDrawing && this.opts.atomVisualization === "default") {
      this.initPseudoElements();
    }
    this.rotateDrawing();
  }
  /**
   * Initializes rings and ringbonds for the current molecule.
   */
  initRings() {
    const openBonds = /* @__PURE__ */ new Map();
    for (let i = this.graph.vertices.length - 1; i >= 0; i--) {
      const vertex = this.graph.vertices[i];
      if (vertex.value.ringbonds.length === 0) {
        continue;
      }
      for (let j = 0; j < vertex.value.ringbonds.length; j++) {
        const ringbondId = vertex.value.ringbonds[j].id;
        const ringbondBond = vertex.value.ringbonds[j].bond;
        if (!openBonds.has(ringbondId)) {
          openBonds.set(ringbondId, [vertex.id, ringbondBond]);
        } else {
          const sourceVertexId = vertex.id;
          const targetVertexId = openBonds.get(ringbondId)[0];
          const targetRingbondBond = openBonds.get(ringbondId)[1];
          const edge = new Edge(sourceVertexId, targetVertexId, 1);
          edge.setBondType(targetRingbondBond || ringbondBond || "-");
          const edgeId = this.graph.addEdge(edge);
          const targetVertex = this.graph.vertices[targetVertexId];
          vertex.addRingbondChild(targetVertexId, j);
          vertex.value.addNeighbouringElement(targetVertex.value.element);
          targetVertex.addRingbondChild(sourceVertexId, j);
          targetVertex.value.addNeighbouringElement(vertex.value.element);
          vertex.edges.push(edgeId);
          targetVertex.edges.push(edgeId);
          openBonds.delete(ringbondId);
        }
      }
    }
    const rings = SSSR.getRings(this.graph, this.opts.experimentalSSSR);
    if (rings === null) {
      return;
    }
    for (let i = 0; i < rings.length; i++) {
      const ringVertices = [...rings[i]];
      const ringId = this.addRing(new Ring(ringVertices));
      for (let j = 0; j < ringVertices.length; j++) {
        this.graph.vertices[ringVertices[j]].value.rings.push(ringId);
      }
    }
    for (let i = 0; i < this.rings.length - 1; i++) {
      for (let j = i + 1; j < this.rings.length; j++) {
        const a = this.rings[i];
        const b = this.rings[j];
        const ringConnection = new RingConnection(a, b);
        if (ringConnection.vertices.size > 0) {
          this.addRingConnection(ringConnection);
        }
      }
    }
    for (let i = 0; i < this.rings.length; i++) {
      const ring = this.rings[i];
      ring.neighbours = RingConnection.getNeighbours(
        this.ringConnections,
        ring.id
      );
    }
    for (let i = 0; i < this.rings.length; i++) {
      const ring = this.rings[i];
      this.graph.vertices[ring.members[0]].value.addAnchoredRing(ring.id);
    }
    this.backupRingInformation();
    while (this.rings.length > 0) {
      let id = -1;
      for (let i = 0; i < this.rings.length; i++) {
        const ring2 = this.rings[i];
        if (this.isPartOfBridgedRing(ring2.id) && !ring2.isBridged) {
          id = ring2.id;
        }
      }
      if (id === -1) {
        break;
      }
      const ring = this.getRing(id);
      const involvedRings = this.getBridgedRingRings(ring.id);
      this.bridgedRing = true;
      this.createBridgedRing(involvedRings, ring.members[0]);
      for (let i = 0; i < involvedRings.length; i++) {
        this.removeRing(involvedRings[i]);
      }
    }
  }
  initHydrogens() {
    if (!this.opts.explicitHydrogens) {
      for (let i = 0; i < this.graph.vertices.length; i++) {
        const vertex = this.graph.vertices[i];
        if (vertex.value.element !== "H") {
          continue;
        }
        const neighbour = this.graph.vertices[vertex.neighbours[0]];
        neighbour.value.hasHydrogen = true;
        if (!neighbour.value.isStereoCenter || neighbour.value.rings.length < 2 && !neighbour.value.bridgedRing || neighbour.value.bridgedRing && neighbour.value.originalRings.length < 2) {
          vertex.value.isDrawn = false;
        }
      }
    }
  }
  /**
   * Returns all rings connected by bridged bonds starting from the ring with the supplied ring id.
   *
   * @param {Number} ringId A ring id.
   * @returns {Number[]} An array containing all ring ids of rings part of a bridged ring system.
   */
  getBridgedRingRings(ringId) {
    const involvedRings = [];
    const that = this;
    const recurse = function(r) {
      const ring = that.getRing(r);
      involvedRings.push(r);
      for (let i = 0; i < ring.neighbours.length; i++) {
        const n = ring.neighbours[i];
        if (involvedRings.indexOf(n) === -1 && n !== r && RingConnection.isBridge(
          that.ringConnections,
          that.graph.vertices,
          r,
          n
        )) {
          recurse(n);
        }
      }
    };
    recurse(ringId);
    return ArrayHelper.unique(involvedRings);
  }
  /**
   * Checks whether or not a ring is part of a bridged ring.
   *
   * @param {Number} ringId A ring id.
   * @returns {Boolean} A boolean indicating whether or not the supplied ring (by id) is part of a bridged ring system.
   */
  isPartOfBridgedRing(ringId) {
    for (let i = 0; i < this.ringConnections.length; i++) {
      if (this.ringConnections[i].containsRing(ringId) && this.ringConnections[i].isBridge(this.graph.vertices)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Creates a bridged ring.
   *
   * @param {Number[]} ringIds An array of ids of rings involved in the bridged ring.
   * @param {Number} sourceVertexId The vertex id to start the bridged ring discovery from.
   * @returns {Ring} The bridged ring.
   */
  createBridgedRing(ringIds, sourceVertexId) {
    const ringMembers = /* @__PURE__ */ new Set();
    const vertices = /* @__PURE__ */ new Set();
    const neighbours = /* @__PURE__ */ new Set();
    for (let i = 0; i < ringIds.length; i++) {
      const ring2 = this.getRing(ringIds[i]);
      ring2.isPartOfBridged = true;
      for (let j = 0; j < ring2.members.length; j++) {
        vertices.add(ring2.members[j]);
      }
      for (let j = 0; j < ring2.neighbours.length; j++) {
        const id = ring2.neighbours[j];
        if (ringIds.indexOf(id) === -1) {
          neighbours.add(ring2.neighbours[j]);
        }
      }
    }
    const leftovers = /* @__PURE__ */ new Set();
    for (const id of vertices) {
      const vertex = this.graph.vertices[id];
      const intersection = ArrayHelper.intersection(
        ringIds,
        vertex.value.rings
      );
      if (vertex.value.rings.length === 1 || intersection.length === 1) {
        ringMembers.add(vertex.id);
      } else {
        leftovers.add(vertex.id);
      }
    }
    const tmp = [];
    const insideRing = [];
    for (const id of leftovers) {
      const vertex = this.graph.vertices[id];
      let onRing = false;
      for (let j = 0; j < vertex.edges.length; j++) {
        if (this.edgeRingCount(vertex.edges[j]) === 1) {
          onRing = true;
        }
      }
      if (onRing) {
        vertex.value.isBridgeNode = true;
        ringMembers.add(vertex.id);
      } else {
        vertex.value.isBridge = true;
        ringMembers.add(vertex.id);
      }
    }
    const ring = new Ring([...ringMembers]);
    this.addRing(ring);
    ring.isBridged = true;
    ring.neighbours = [...neighbours];
    for (let i = 0; i < ringIds.length; i++) {
      ring.rings.push(this.getRing(ringIds[i]).clone());
    }
    for (let i = 0; i < ring.members.length; i++) {
      this.graph.vertices[ring.members[i]].value.bridgedRing = ring.id;
    }
    for (let i = 0; i < insideRing.length; i++) {
      const vertex = this.graph.vertices[insideRing[i]];
      vertex.value.rings = [];
    }
    for (const id of ringMembers) {
      const vertex = this.graph.vertices[id];
      vertex.value.rings = ArrayHelper.removeAll(vertex.value.rings, ringIds);
      vertex.value.rings.push(ring.id);
    }
    for (let i = 0; i < ringIds.length; i++) {
      for (let j = i + 1; j < ringIds.length; j++) {
        this.removeRingConnectionsBetween(ringIds[i], ringIds[j]);
      }
    }
    for (const id of neighbours) {
      const connections = this.getRingConnections(id, ringIds);
      for (let j = 0; j < connections.length; j++) {
        this.getRingConnection(connections[j]).updateOther(ring.id, id);
      }
      this.getRing(id).neighbours.push(ring.id);
    }
    return ring;
  }
  /**
   * Checks whether or not two vertices are in the same ring.
   *
   * @param {Vertex} vertexA A vertex.
   * @param {Vertex} vertexB A vertex.
   * @returns {Boolean} A boolean indicating whether or not the two vertices are in the same ring.
   */
  areVerticesInSameRing(vertexA, vertexB) {
    for (let i = 0; i < vertexA.value.rings.length; i++) {
      for (let j = 0; j < vertexB.value.rings.length; j++) {
        if (vertexA.value.rings[i] === vertexB.value.rings[j]) {
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Returns an array of ring ids shared by both vertices.
   *
   * @param {Vertex} vertexA A vertex.
   * @param {Vertex} vertexB A vertex.
   * @returns {Number[]} An array of ids of rings shared by the two vertices.
   */
  getCommonRings(vertexA, vertexB) {
    const commonRings = [];
    for (let i = 0; i < vertexA.value.rings.length; i++) {
      for (let j = 0; j < vertexB.value.rings.length; j++) {
        if (vertexA.value.rings[i] === vertexB.value.rings[j]) {
          commonRings.push(vertexA.value.rings[i]);
        }
      }
    }
    return commonRings;
  }
  /**
   * Returns the aromatic or largest ring shared by the two vertices.
   *
   * @param {Vertex} vertexA A vertex.
   * @param {Vertex} vertexB A vertex.
   * @returns {(Ring|null)} If an aromatic common ring exists, that ring, else the largest (non-aromatic) ring, else null.
   */
  getLargestOrAromaticCommonRing(vertexA, vertexB) {
    const commonRings = this.getCommonRings(vertexA, vertexB);
    let maxSize = 0;
    let largestCommonRing = null;
    for (let i = 0; i < commonRings.length; i++) {
      const ring = this.getRing(commonRings[i]);
      const size = ring.getSize();
      if (ring.isBenzeneLike(this.graph.vertices)) {
        return ring;
      } else if (size > maxSize) {
        maxSize = size;
        largestCommonRing = ring;
      }
    }
    return largestCommonRing;
  }
  /**
   * Returns an array of vertices positioned at a specified location.
   *
   * @param {Vector2} position The position to search for vertices.
   * @param {Number} radius The radius within to search.
   * @param {Number} excludeVertexId A vertex id to be excluded from the search results.
   * @returns {Number[]} An array containing vertex ids in a given location.
   */
  getVerticesAt(position, radius, excludeVertexId) {
    const locals = [];
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      if (vertex.id === excludeVertexId || !vertex.positioned) {
        continue;
      }
      const distance = position.distanceSq(vertex.position);
      if (distance <= radius * radius) {
        locals.push(vertex.id);
      }
    }
    return locals;
  }
  /**
   * Returns the closest vertex (connected as well as unconnected).
   *
   * @param {Vertex} vertex The vertex of which to find the closest other vertex.
   * @returns {Vertex} The closest vertex.
   */
  getClosestVertex(vertex) {
    let minDist = 99999;
    let minVertex = null;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const v = this.graph.vertices[i];
      if (v.id === vertex.id) {
        continue;
      }
      const distSq = vertex.position.distanceSq(v.position);
      if (distSq < minDist) {
        minDist = distSq;
        minVertex = v;
      }
    }
    return minVertex;
  }
  /**
   * Add a ring to this representation of a molecule.
   *
   * @param {Ring} ring A new ring.
   * @returns {Number} The ring id of the new ring.
   */
  addRing(ring) {
    ring.id = this.ringIdCounter++;
    this.rings.push(ring);
    return ring.id;
  }
  /**
   * Removes a ring from the array of rings associated with the current molecule.
   *
   * @param {Number} ringId A ring id.
   */
  removeRing(ringId) {
    this.rings = this.rings.filter(function(item) {
      return item.id !== ringId;
    });
    this.ringConnections = this.ringConnections.filter(function(item) {
      return item.firstRingId !== ringId && item.secondRingId !== ringId;
    });
    for (let i = 0; i < this.rings.length; i++) {
      const r = this.rings[i];
      r.neighbours = r.neighbours.filter(function(item) {
        return item !== ringId;
      });
    }
  }
  /**
   * Gets a ring object from the array of rings associated with the current molecule by its id. The ring id is not equal to the index, since rings can be added and removed when processing bridged rings.
   *
   * @param {Number} ringId A ring id.
   * @returns {Ring} A ring associated with the current molecule.
   */
  getRing(ringId) {
    for (let i = 0; i < this.rings.length; i++) {
      if (this.rings[i].id === ringId) {
        return this.rings[i];
      }
    }
  }
  /**
   * Add a ring connection to this representation of a molecule.
   *
   * @param {RingConnection} ringConnection A new ringConnection.
   * @returns {Number} The ring connection id of the new ring connection.
   */
  addRingConnection(ringConnection) {
    ringConnection.id = this.ringConnectionIdCounter++;
    this.ringConnections.push(ringConnection);
    return ringConnection.id;
  }
  /**
   * Removes a ring connection from the array of rings connections associated with the current molecule.
   *
   * @param {Number} ringConnectionId A ring connection id.
   */
  removeRingConnection(ringConnectionId) {
    this.ringConnections = this.ringConnections.filter(function(item) {
      return item.id !== ringConnectionId;
    });
  }
  /**
   * Removes all ring connections between two vertices.
   *
   * @param {Number} vertexIdA A vertex id.
   * @param {Number} vertexIdB A vertex id.
   */
  removeRingConnectionsBetween(vertexIdA, vertexIdB) {
    const toRemove = [];
    for (let i = 0; i < this.ringConnections.length; i++) {
      const ringConnection = this.ringConnections[i];
      if (ringConnection.firstRingId === vertexIdA && ringConnection.secondRingId === vertexIdB || ringConnection.firstRingId === vertexIdB && ringConnection.secondRingId === vertexIdA) {
        toRemove.push(ringConnection.id);
      }
    }
    for (let i = 0; i < toRemove.length; i++) {
      this.removeRingConnection(toRemove[i]);
    }
  }
  /**
   * Get a ring connection with a given id.
   *
   * @param {Number} id
   * @returns {RingConnection} The ring connection with the specified id.
   */
  getRingConnection(id) {
    for (let i = 0; i < this.ringConnections.length; i++) {
      if (this.ringConnections[i].id === id) {
        return this.ringConnections[i];
      }
    }
  }
  /**
   * Get the ring connections between a ring and a set of rings.
   *
   * @param {Number} ringId A ring id.
   * @param {Number[]} ringIds An array of ring ids.
   * @returns {Number[]} An array of ring connection ids.
   */
  getRingConnections(ringId, ringIds) {
    const ringConnections = [];
    for (let i = 0; i < this.ringConnections.length; i++) {
      const rc = this.ringConnections[i];
      for (let j = 0; j < ringIds.length; j++) {
        const id = ringIds[j];
        if (rc.firstRingId === ringId && rc.secondRingId === id || rc.firstRingId === id && rc.secondRingId === ringId) {
          ringConnections.push(rc.id);
        }
      }
    }
    return ringConnections;
  }
  /**
   * Returns the overlap score of the current molecule based on its positioned vertices. The higher the score, the more overlaps occur in the structure drawing.
   *
   * @returns {Object} Returns the total overlap score and the overlap score of each vertex sorted by score (higher to lower). Example: { total: 99, scores: [ { id: 0, score: 22 }, ... ]  }
   */
  getOverlapScore() {
    let total = 0;
    const overlapScores = new Float32Array(this.graph.vertices.length);
    for (let i = 0; i < this.graph.vertices.length; i++) {
      overlapScores[i] = 0;
    }
    for (let i = 0; i < this.graph.vertices.length; i++) {
      let j = this.graph.vertices.length;
      while (--j > i) {
        const a = this.graph.vertices[i];
        const b = this.graph.vertices[j];
        if (!a.value.isDrawn || !b.value.isDrawn) {
          continue;
        }
        const dist = Vector2.subtract(a.position, b.position).lengthSq();
        if (dist < this.opts.bondLengthSq) {
          const weighted = (this.opts.bondLength - Math.sqrt(dist)) / this.opts.bondLength;
          total += weighted;
          overlapScores[i] += weighted;
          overlapScores[j] += weighted;
        }
      }
    }
    const sortable = [];
    for (let i = 0; i < this.graph.vertices.length; i++) {
      sortable.push({
        id: i,
        score: overlapScores[i]
      });
    }
    sortable.sort(function(a, b) {
      return b.score - a.score;
    });
    return {
      total,
      scores: sortable,
      vertexScores: overlapScores
    };
  }
  /**
   * When drawing a double bond, choose the side to place the double bond. E.g. a double bond should always been drawn inside a ring.
   *
   * @param {Vertex} vertexA A vertex.
   * @param {Vertex} vertexB A vertex.
   * @param {Vector2[]} sides An array containing the two normals of the line spanned by the two provided vertices.
   * @returns {Object} Returns an object containing the following information: {
          totalSideCount: Counts the sides of each vertex in the molecule, is an array [ a, b ],
          totalPosition: Same as position, but based on entire molecule,
          sideCount: Counts the sides of each neighbour, is an array [ a, b ],
          position: which side to position the second bond, is 0 or 1, represents the index in the normal array. This is based on only the neighbours
          anCount: the number of neighbours of vertexA,
          bnCount: the number of neighbours of vertexB
      }
   */
  chooseSide(vertexA, vertexB, sides) {
    const an = vertexA.getNeighbours(vertexB.id);
    const bn = vertexB.getNeighbours(vertexA.id);
    const anCount = an.length;
    const bnCount = bn.length;
    const tn = ArrayHelper.merge(an, bn);
    const sideCount = [0, 0];
    for (let i = 0; i < tn.length; i++) {
      const v = this.graph.vertices[tn[i]].position;
      if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {
        sideCount[0]++;
      } else {
        sideCount[1]++;
      }
    }
    const totalSideCount = [0, 0];
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const v = this.graph.vertices[i].position;
      if (v.sameSideAs(vertexA.position, vertexB.position, sides[0])) {
        totalSideCount[0]++;
      } else {
        totalSideCount[1]++;
      }
    }
    return {
      totalSideCount,
      totalPosition: totalSideCount[0] > totalSideCount[1] ? 0 : 1,
      sideCount,
      position: sideCount[0] > sideCount[1] ? 0 : 1,
      anCount,
      bnCount
    };
  }
  /**
   * Sets the center for a ring.
   *
   * @param {Ring} ring A ring.
   */
  setRingCenter(ring) {
    const ringSize = ring.getSize();
    const total = new Vector2(0, 0);
    for (let i = 0; i < ringSize; i++) {
      total.add(this.graph.vertices[ring.members[i]].position);
    }
    ring.center = total.divide(ringSize);
  }
  /**
   * Gets the center of a ring contained within a bridged ring and containing a given vertex.
   *
   * @param {Ring} ring A bridged ring.
   * @param {Vertex} vertex A vertex.
   * @returns {Vector2} The center of the subring that containing the vertex.
   */
  getSubringCenter(ring, vertex) {
    const rings = vertex.value.originalRings;
    let center = ring.center;
    let smallest = Number.MAX_VALUE;
    for (let i = 0; i < rings.length; i++) {
      for (let j = 0; j < ring.rings.length; j++) {
        if (rings[i] === ring.rings[j].id) {
          if (ring.rings[j].getSize() < smallest) {
            center = ring.rings[j].center;
            smallest = ring.rings[j].getSize();
          }
        }
      }
    }
    return center;
  }
  /**
   * Draw the actual edges as bonds to the canvas.
   *
   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
   */
  drawEdges(debug) {
    const that = this;
    const drawn = Array(this.graph.edges.length);
    drawn.fill(false);
    this.graph.traverseBF(0, function(vertex) {
      const edges = that.graph.getEdges(vertex.id);
      for (let i = 0; i < edges.length; i++) {
        const edgeId = edges[i];
        if (!drawn[edgeId]) {
          drawn[edgeId] = true;
          that.drawEdge(edgeId, debug);
        }
      }
    });
    if (!this.bridgedRing) {
      for (let i = 0; i < this.rings.length; i++) {
        const ring = this.rings[i];
        if (this.isRingAromatic(ring)) {
          this.canvasWrapper.drawAromaticityRing(ring);
        }
      }
    }
  }
  /**
   * Draw the an edge as a bonds to the canvas.
   *
   * @param {Number} edgeId An edge id.
   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
   */
  drawEdge(edgeId, debug) {
    const that = this;
    const edge = this.graph.edges[edgeId];
    const vertexA = this.graph.vertices[edge.sourceId];
    const vertexB = this.graph.vertices[edge.targetId];
    const elementA = vertexA.value.element;
    const elementB = vertexB.value.element;
    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && this.opts.atomVisualization === "default") {
      return;
    }
    const a = vertexA.position;
    const b = vertexB.position;
    const normals = this.getEdgeNormals(edge);
    const sides = ArrayHelper.clone(normals);
    sides[0].multiplyScalar(10).add(a);
    sides[1].multiplyScalar(10).add(a);
    if (edge.bondType === "=" || this.getRingbondType(vertexA, vertexB) === "=" || edge.isPartOfAromaticRing && this.bridgedRing) {
      const inRing = this.areVerticesInSameRing(vertexA, vertexB);
      const s = this.chooseSide(vertexA, vertexB, sides);
      if (inRing) {
        const lcr = this.getLargestOrAromaticCommonRing(vertexA, vertexB);
        const center = lcr.center;
        normals[0].multiplyScalar(that.opts.bondSpacing);
        normals[1].multiplyScalar(that.opts.bondSpacing);
        let line = null;
        if (center.sameSideAs(
          vertexA.position,
          vertexB.position,
          Vector2.add(a, normals[0])
        )) {
          line = new Line(
            Vector2.add(a, normals[0]),
            Vector2.add(b, normals[0]),
            elementA,
            elementB
          );
        } else {
          line = new Line(
            Vector2.add(a, normals[1]),
            Vector2.add(b, normals[1]),
            elementA,
            elementB
          );
        }
        line.shorten(
          this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength
        );
        if (edge.isPartOfAromaticRing) {
          this.canvasWrapper.drawLine(line, true);
        } else {
          this.canvasWrapper.drawLine(line);
        }
        this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal()) {
        normals[0].multiplyScalar(that.opts.halfBondSpacing);
        normals[1].multiplyScalar(that.opts.halfBondSpacing);
        const lineA = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        );
        const lineB = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        this.canvasWrapper.drawLine(lineA);
        this.canvasWrapper.drawLine(lineB);
      } else if (s.anCount === 0 && s.bnCount > 1 || s.bnCount === 0 && s.anCount > 1) {
        normals[0].multiplyScalar(that.opts.halfBondSpacing);
        normals[1].multiplyScalar(that.opts.halfBondSpacing);
        const lineA = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        );
        const lineB = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        this.canvasWrapper.drawLine(lineA);
        this.canvasWrapper.drawLine(lineB);
      } else if (s.sideCount[0] > s.sideCount[1]) {
        normals[0].multiplyScalar(that.opts.bondSpacing);
        normals[1].multiplyScalar(that.opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        );
        line.shorten(
          this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength
        );
        this.canvasWrapper.drawLine(line);
        this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (s.sideCount[0] < s.sideCount[1]) {
        normals[0].multiplyScalar(that.opts.bondSpacing);
        normals[1].multiplyScalar(that.opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        line.shorten(
          this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength
        );
        this.canvasWrapper.drawLine(line);
        this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (s.totalSideCount[0] > s.totalSideCount[1]) {
        normals[0].multiplyScalar(that.opts.bondSpacing);
        normals[1].multiplyScalar(that.opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        );
        line.shorten(
          this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength
        );
        this.canvasWrapper.drawLine(line);
        this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (s.totalSideCount[0] <= s.totalSideCount[1]) {
        normals[0].multiplyScalar(that.opts.bondSpacing);
        normals[1].multiplyScalar(that.opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        line.shorten(
          this.opts.bondLength - this.opts.shortBondLength * this.opts.bondLength
        );
        this.canvasWrapper.drawLine(line);
        this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else {
      }
    } else if (edge.bondType === "#") {
      normals[0].multiplyScalar(that.opts.bondSpacing / 1.5);
      normals[1].multiplyScalar(that.opts.bondSpacing / 1.5);
      const lineA = new Line(
        Vector2.add(a, normals[0]),
        Vector2.add(b, normals[0]),
        elementA,
        elementB
      );
      const lineB = new Line(
        Vector2.add(a, normals[1]),
        Vector2.add(b, normals[1]),
        elementA,
        elementB
      );
      this.canvasWrapper.drawLine(lineA);
      this.canvasWrapper.drawLine(lineB);
      this.canvasWrapper.drawLine(new Line(a, b, elementA, elementB));
    } else if (edge.bondType === ".") {
    } else {
      const isChiralCenterA = vertexA.value.isStereoCenter;
      const isChiralCenterB = vertexB.value.isStereoCenter;
      if (edge.wedge === "up") {
        this.canvasWrapper.drawWedge(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      } else if (edge.wedge === "down") {
        this.canvasWrapper.drawDashedWedge(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      } else {
        this.canvasWrapper.drawLine(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      }
    }
    if (debug) {
      const midpoint = Vector2.midpoint(a, b);
      this.canvasWrapper.drawDebugText(midpoint.x, midpoint.y, "e: " + edgeId);
    }
  }
  /**
   * Draws the vertices representing atoms to the canvas.
   *
   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.
   */
  drawVertices(debug) {
    let i = this.graph.vertices.length;
    for (let i2 = 0; i2 < this.graph.vertices.length; i2++) {
      const vertex = this.graph.vertices[i2];
      const atom = vertex.value;
      let charge = 0;
      let isotope = 0;
      const bondCount = vertex.value.bondCount;
      const element = atom.element;
      let hydrogens = Atom.maxBonds[element] - bondCount;
      const dir = vertex.getTextDirection(this.graph.vertices);
      const isTerminal = this.opts.terminalCarbons || element !== "C" || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;
      const isCarbon = atom.element === "C";
      if (atom.element === "N" && atom.isPartOfAromaticRing) {
        hydrogens = 0;
      }
      if (atom.bracket) {
        hydrogens = atom.bracket.hcount;
        charge = atom.bracket.charge;
        isotope = atom.bracket.isotope;
      }
      if (this.opts.atomVisualization === "allballs") {
        this.canvasWrapper.drawBall(
          vertex.position.x,
          vertex.position.y,
          element
        );
      } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || this.graph.vertices.length === 1) {
        if (this.opts.atomVisualization === "default") {
          this.canvasWrapper.drawText(
            vertex.position.x,
            vertex.position.y,
            element,
            hydrogens,
            dir,
            isTerminal,
            charge,
            isotope,
            this.graph.vertices.length,
            atom.getAttachedPseudoElements()
          );
        } else if (this.opts.atomVisualization === "balls") {
          this.canvasWrapper.drawBall(
            vertex.position.x,
            vertex.position.y,
            element
          );
        }
      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned === true) {
        const a = this.graph.vertices[vertex.neighbours[0]].position;
        const b = this.graph.vertices[vertex.neighbours[1]].position;
        const angle = Vector2.threePointangle(vertex.position, a, b);
        if (Math.abs(Math.PI - angle) < 0.1) {
          this.canvasWrapper.drawPoint(
            vertex.position.x,
            vertex.position.y,
            element
          );
        }
      }
      if (debug) {
        const value = "v: " + vertex.id + " " + ArrayHelper.print(atom.ringbonds);
        this.canvasWrapper.drawDebugText(
          vertex.position.x,
          vertex.position.y,
          value
        );
      } else {
      }
    }
    if (this.opts.debug) {
      for (let i2 = 0; i2 < this.rings.length; i2++) {
        const center = this.rings[i2].center;
        this.canvasWrapper.drawDebugPoint(
          center.x,
          center.y,
          "r: " + this.rings[i2].id
        );
      }
    }
  }
  /**
   * Position the vertices according to their bonds and properties.
   */
  position() {
    let startVertex = null;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      if (this.graph.vertices[i].value.bridgedRing !== null) {
        startVertex = this.graph.vertices[i];
        break;
      }
    }
    for (let i = 0; i < this.rings.length; i++) {
      if (this.rings[i].isBridged) {
        startVertex = this.graph.vertices[this.rings[i].members[0]];
      }
    }
    if (this.rings.length > 0 && startVertex === null) {
      startVertex = this.graph.vertices[this.rings[0].members[0]];
    }
    if (startVertex === null) {
      startVertex = this.graph.vertices[0];
    }
    this.createNextBond(startVertex, null, 0);
  }
  /**
   * Stores the current information associated with rings.
   */
  backupRingInformation() {
    this.originalRings = [];
    this.originalRingConnections = [];
    for (let i = 0; i < this.rings.length; i++) {
      this.originalRings.push(this.rings[i]);
    }
    for (let i = 0; i < this.ringConnections.length; i++) {
      this.originalRingConnections.push(this.ringConnections[i]);
    }
    for (let i = 0; i < this.graph.vertices.length; i++) {
      this.graph.vertices[i].value.backupRings();
    }
  }
  /**
   * Restores the most recently backed up information associated with rings.
   */
  restoreRingInformation() {
    const bridgedRings = this.getBridgedRings();
    this.rings = [];
    this.ringConnections = [];
    for (let i = 0; i < bridgedRings.length; i++) {
      const bridgedRing = bridgedRings[i];
      for (let j = 0; j < bridgedRing.rings.length; j++) {
        const ring = bridgedRing.rings[j];
        this.originalRings[ring.id].center = ring.center;
      }
    }
    for (let i = 0; i < this.originalRings.length; i++) {
      this.rings.push(this.originalRings[i]);
    }
    for (let i = 0; i < this.originalRingConnections.length; i++) {
      this.ringConnections.push(this.originalRingConnections[i]);
    }
    for (let i = 0; i < this.graph.vertices.length; i++) {
      this.graph.vertices[i].value.restoreRings();
    }
  }
  // TODO: This needs some cleaning up
  /**
   * Creates a new ring, that is, positiones all the vertices inside a ring.
   *
   * @param {Ring} ring The ring to position.
   * @param {(Vector2|null)} [center=null] The center of the ring to be created.
   * @param {(Vertex|null)} [startVertex=null] The first vertex to be positioned inside the ring.
   * @param {(Vertex|null)} [previousVertex=null] The last vertex that was positioned.
   * @param {Boolean} [previousVertex=false] A boolean indicating whether or not this ring was force positioned already - this is needed after force layouting a ring, in order to draw rings connected to it.
   */
  createRing(ring, center = null, startVertex = null, previousVertex = null) {
    if (ring.positioned) {
      return;
    }
    center = center ? center : new Vector2(0, 0);
    const orderedNeighbours = ring.getOrderedNeighbours(this.ringConnections);
    const startingAngle = startVertex ? Vector2.subtract(startVertex.position, center).angle() : 0;
    const radius = MathHelper.polyCircumradius(
      this.opts.bondLength,
      ring.getSize()
    );
    const angle = MathHelper.centralAngle(ring.getSize());
    ring.centralAngle = angle;
    let a = startingAngle;
    const that = this;
    let startVertexId = startVertex ? startVertex.id : null;
    if (ring.members.indexOf(startVertexId) === -1) {
      if (startVertex) {
        startVertex.positioned = false;
      }
      startVertexId = ring.members[0];
    }
    if (ring.isBridged) {
      this.graph.kkLayout(
        ring.members.slice(),
        center,
        startVertex.id,
        ring,
        this.opts.bondLength,
        this.opts.kkThreshold,
        this.opts.kkInnerThreshold,
        this.opts.kkMaxIteration,
        this.opts.kkMaxInnerIteration,
        this.opts.kkMaxEnergy
      );
      ring.positioned = true;
      this.setRingCenter(ring);
      center = ring.center;
      for (let i = 0; i < ring.rings.length; i++) {
        this.setRingCenter(ring.rings[i]);
      }
    } else {
      ring.eachMember(
        this.graph.vertices,
        function(v) {
          const vertex = that.graph.vertices[v];
          if (!vertex.positioned) {
            vertex.setPosition(
              center.x + Math.cos(a) * radius,
              center.y + Math.sin(a) * radius
            );
          }
          a += angle;
          if (!ring.isBridged || ring.rings.length < 3) {
            vertex.angle = a;
            vertex.positioned = true;
          }
        },
        startVertexId,
        previousVertex ? previousVertex.id : null
      );
    }
    ring.positioned = true;
    ring.center = center;
    for (let i = 0; i < orderedNeighbours.length; i++) {
      const neighbour = this.getRing(orderedNeighbours[i].neighbour);
      if (neighbour.positioned) {
        continue;
      }
      const vertices = RingConnection.getVertices(
        this.ringConnections,
        ring.id,
        neighbour.id
      );
      if (vertices.length === 2) {
        ring.isFused = true;
        neighbour.isFused = true;
        const vertexA = this.graph.vertices[vertices[0]];
        const vertexB = this.graph.vertices[vertices[1]];
        const midpoint = Vector2.midpoint(vertexA.position, vertexB.position);
        const normals = Vector2.normals(vertexA.position, vertexB.position);
        normals[0].normalize();
        normals[1].normalize();
        const r = MathHelper.polyCircumradius(
          this.opts.bondLength,
          neighbour.getSize()
        );
        const apothem = MathHelper.apothem(r, neighbour.getSize());
        normals[0].multiplyScalar(apothem).add(midpoint);
        normals[1].multiplyScalar(apothem).add(midpoint);
        let nextCenter = normals[0];
        if (Vector2.subtract(center, normals[1]).lengthSq() > Vector2.subtract(center, normals[0]).lengthSq()) {
          nextCenter = normals[1];
        }
        const posA = Vector2.subtract(vertexA.position, nextCenter);
        const posB = Vector2.subtract(vertexB.position, nextCenter);
        if (posA.clockwise(posB) === -1) {
          if (!neighbour.positioned) {
            this.createRing(neighbour, nextCenter, vertexA, vertexB);
          }
        } else {
          if (!neighbour.positioned) {
            this.createRing(neighbour, nextCenter, vertexB, vertexA);
          }
        }
      } else if (vertices.length === 1) {
        ring.isSpiro = true;
        neighbour.isSpiro = true;
        const vertexA = this.graph.vertices[vertices[0]];
        const nextCenter = Vector2.subtract(center, vertexA.position);
        nextCenter.invert();
        nextCenter.normalize();
        const r = MathHelper.polyCircumradius(
          this.opts.bondLength,
          neighbour.getSize()
        );
        nextCenter.multiplyScalar(r);
        nextCenter.add(vertexA.position);
        if (!neighbour.positioned) {
          this.createRing(neighbour, nextCenter, vertexA);
        }
      }
    }
    for (let i = 0; i < ring.members.length; i++) {
      const ringMember = this.graph.vertices[ring.members[i]];
      const ringMemberNeighbours = ringMember.neighbours;
      for (let j = 0; j < ringMemberNeighbours.length; j++) {
        const v = this.graph.vertices[ringMemberNeighbours[j]];
        if (v.positioned) {
          continue;
        }
        v.value.isConnectedToRing = true;
        this.createNextBond(v, ringMember, 0);
      }
    }
  }
  /**
   * Rotate an entire subtree by an angle around a center.
   *
   * @param {Number} vertexId A vertex id (the root of the sub-tree).
   * @param {Number} parentVertexId A vertex id in the previous direction of the subtree that is to rotate.
   * @param {Number} angle An angle in randians.
   * @param {Vector2} center The rotational center.
   */
  rotateSubtree(vertexId, parentVertexId, angle, center) {
    const that = this;
    this.graph.traverseTree(vertexId, parentVertexId, function(vertex) {
      vertex.position.rotateAround(angle, center);
      for (let i = 0; i < vertex.value.anchoredRings.length; i++) {
        const ring = that.rings[vertex.value.anchoredRings[i]];
        if (ring) {
          ring.center.rotateAround(angle, center);
        }
      }
    });
  }
  /**
   * Gets the overlap score of a subtree.
   *
   * @param {Number} vertexId A vertex id (the root of the sub-tree).
   * @param {Number} parentVertexId A vertex id in the previous direction of the subtree.
   * @param {Number[]} vertexOverlapScores An array containing the vertex overlap scores indexed by vertex id.
   * @returns {Object} An object containing the total overlap score and the center of mass of the subtree weighted by overlap score { value: 0.2, center: new Vector2() }.
   */
  getSubtreeOverlapScore(vertexId, parentVertexId, vertexOverlapScores) {
    const that = this;
    let score = 0;
    const center = new Vector2(0, 0);
    let count = 0;
    this.graph.traverseTree(vertexId, parentVertexId, function(vertex) {
      if (!vertex.value.isDrawn) {
        return;
      }
      const s = vertexOverlapScores[vertex.id];
      if (s > that.opts.overlapSensitivity) {
        score += s;
        count++;
      }
      const position = that.graph.vertices[vertex.id].position.clone();
      position.multiplyScalar(s);
      center.add(position);
    });
    center.divide(score);
    return {
      value: score / count,
      center
    };
  }
  /**
   * Returns the current (positioned vertices so far) center of mass.
   *
   * @returns {Vector2} The current center of mass.
   */
  getCurrentCenterOfMass() {
    const total = new Vector2(0, 0);
    let count = 0;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      if (vertex.positioned) {
        total.add(vertex.position);
        count++;
      }
    }
    return total.divide(count);
  }
  /**
   * Returns the current (positioned vertices so far) center of mass in the neighbourhood of a given position.
   *
   * @param {Vector2} vec The point at which to look for neighbours.
   * @param {Number} [r=currentBondLength*2.0] The radius of vertices to include.
   * @returns {Vector2} The current center of mass.
   */
  getCurrentCenterOfMassInNeigbourhood(vec, r = this.opts.bondLength * 2) {
    const total = new Vector2(0, 0);
    let count = 0;
    const rSq = r * r;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      if (vertex.positioned && vec.distanceSq(vertex.position) < rSq) {
        total.add(vertex.position);
        count++;
      }
    }
    return total.divide(count);
  }
  /**
   * Resolve primary (exact) overlaps, such as two vertices that are connected to the same ring vertex.
   */
  resolvePrimaryOverlaps() {
    const overlaps = [];
    const done = Array(this.graph.vertices.length);
    for (let i = 0; i < this.rings.length; i++) {
      const ring = this.rings[i];
      for (let j = 0; j < ring.members.length; j++) {
        const vertex = this.graph.vertices[ring.members[j]];
        if (done[vertex.id]) {
          continue;
        }
        done[vertex.id] = true;
        const nonRingNeighbours = this.getNonRingNeighbours(vertex.id);
        if (nonRingNeighbours.length > 1) {
          const rings = [];
          for (let k = 0; k < vertex.value.rings.length; k++) {
            rings.push(vertex.value.rings[k]);
          }
          overlaps.push({
            common: vertex,
            rings,
            vertices: nonRingNeighbours
          });
        } else if (nonRingNeighbours.length === 1 && vertex.value.rings.length === 2) {
          const rings = [];
          for (let k = 0; k < vertex.value.rings.length; k++) {
            rings.push(vertex.value.rings[k]);
          }
          overlaps.push({
            common: vertex,
            rings,
            vertices: nonRingNeighbours
          });
        }
      }
    }
    for (let i = 0; i < overlaps.length; i++) {
      const overlap = overlaps[i];
      if (overlap.vertices.length === 2) {
        const a = overlap.vertices[0];
        const b = overlap.vertices[1];
        if (!a.value.isDrawn || !b.value.isDrawn) {
          continue;
        }
        const angle = (2 * Math.PI - this.getRing(overlap.rings[0]).getAngle()) / 6;
        this.rotateSubtree(
          a.id,
          overlap.common.id,
          angle,
          overlap.common.position
        );
        this.rotateSubtree(
          b.id,
          overlap.common.id,
          -angle,
          overlap.common.position
        );
        let overlapScore = this.getOverlapScore();
        let subTreeOverlapA = this.getSubtreeOverlapScore(
          a.id,
          overlap.common.id,
          overlapScore.vertexScores
        );
        let subTreeOverlapB = this.getSubtreeOverlapScore(
          b.id,
          overlap.common.id,
          overlapScore.vertexScores
        );
        const total = subTreeOverlapA.value + subTreeOverlapB.value;
        this.rotateSubtree(
          a.id,
          overlap.common.id,
          -2 * angle,
          overlap.common.position
        );
        this.rotateSubtree(
          b.id,
          overlap.common.id,
          2 * angle,
          overlap.common.position
        );
        overlapScore = this.getOverlapScore();
        subTreeOverlapA = this.getSubtreeOverlapScore(
          a.id,
          overlap.common.id,
          overlapScore.vertexScores
        );
        subTreeOverlapB = this.getSubtreeOverlapScore(
          b.id,
          overlap.common.id,
          overlapScore.vertexScores
        );
        if (subTreeOverlapA.value + subTreeOverlapB.value > total) {
          this.rotateSubtree(
            a.id,
            overlap.common.id,
            2 * angle,
            overlap.common.position
          );
          this.rotateSubtree(
            b.id,
            overlap.common.id,
            -2 * angle,
            overlap.common.position
          );
        }
      } else if (overlap.vertices.length === 1) {
        if (overlap.rings.length === 2) {
        }
      }
    }
  }
  /**
   * Resolve secondary overlaps. Those overlaps are due to the structure turning back on itself.
   *
   * @param {Object[]} scores An array of objects sorted descending by score.
   * @param {Number} scores[].id A vertex id.
   * @param {Number} scores[].score The overlap score associated with the vertex id.
   */
  resolveSecondaryOverlaps(scores) {
    for (let i = 0; i < scores.length; i++) {
      if (scores[i].score > this.opts.overlapSensitivity) {
        const vertex = this.graph.vertices[scores[i].id];
        if (vertex.isTerminal()) {
          const closest = this.getClosestVertex(vertex);
          if (closest) {
            let closestPosition = null;
            if (closest.isTerminal()) {
              closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.previousPosition;
            } else {
              closestPosition = closest.id === 0 ? this.graph.vertices[1].position : closest.position;
            }
            const vertexPreviousPosition = vertex.id === 0 ? this.graph.vertices[1].position : vertex.previousPosition;
            vertex.position.rotateAwayFrom(
              closestPosition,
              vertexPreviousPosition,
              MathHelper.toRad(20)
            );
          }
        }
      }
    }
  }
  /**
   * Get the last non-null or 0 angle vertex.
   * @param {Number} vertexId A vertex id.
   * @returns {Vertex} The last vertex with an angle that was not 0 or null.
   */
  getLastVertexWithAngle(vertexId) {
    let angle = 0;
    let vertex = null;
    while (!angle && vertexId) {
      vertex = this.graph.vertices[vertexId];
      angle = vertex.angle;
      vertexId = vertex.parentVertexId;
    }
    return vertex;
  }
  /**
   * Positiones the next vertex thus creating a bond.
   *
   * @param {Vertex} vertex A vertex.
   * @param {Vertex} [previousVertex=null] The previous vertex which has been positioned.
   * @param {Number} [angle=0.0] The (global) angle of the vertex.
   * @param {Boolean} [originShortest=false] Whether the origin is the shortest subtree in the branch.
   * @param {Boolean} [skipPositioning=false] Whether or not to skip positioning and just check the neighbours.
   */
  createNextBond(vertex, previousVertex = null, angle = 0, originShortest = false, skipPositioning = false) {
    if (vertex.positioned && !skipPositioning) {
      return;
    }
    let doubleBondConfigSet = false;
    if (previousVertex) {
      const edge = this.graph.getEdge(vertex.id, previousVertex.id);
      if ((edge.bondType === "/" || edge.bondType === "\\") && ++this.doubleBondConfigCount % 2 === 1) {
        if (this.doubleBondConfig === null) {
          this.doubleBondConfig = edge.bondType;
          doubleBondConfigSet = true;
          if (previousVertex.parentVertexId === null && vertex.value.branchBond) {
            if (this.doubleBondConfig === "/") {
              this.doubleBondConfig = "\\";
            } else if (this.doubleBondConfig === "\\") {
              this.doubleBondConfig = "/";
            }
          }
        }
      }
    }
    if (!skipPositioning) {
      if (!previousVertex) {
        const dummy = new Vector2(this.opts.bondLength, 0);
        dummy.rotate(MathHelper.toRad(-60));
        vertex.previousPosition = dummy;
        vertex.setPosition(this.opts.bondLength, 0);
        vertex.angle = MathHelper.toRad(-60);
        if (vertex.value.bridgedRing === null) {
          vertex.positioned = true;
        }
      } else if (previousVertex.value.rings.length > 0) {
        const neighbours = previousVertex.neighbours;
        let joinedVertex = null;
        let pos = new Vector2(0, 0);
        if (previousVertex.value.bridgedRing === null && previousVertex.value.rings.length > 1) {
          for (let i = 0; i < neighbours.length; i++) {
            const neighbour = this.graph.vertices[neighbours[i]];
            if (ArrayHelper.containsAll(
              neighbour.value.rings,
              previousVertex.value.rings
            )) {
              joinedVertex = neighbour;
              break;
            }
          }
        }
        if (joinedVertex === null) {
          for (let i = 0; i < neighbours.length; i++) {
            const v = this.graph.vertices[neighbours[i]];
            if (v.positioned && this.areVerticesInSameRing(v, previousVertex)) {
              pos.add(Vector2.subtract(v.position, previousVertex.position));
            }
          }
          pos.invert().normalize().multiplyScalar(this.opts.bondLength).add(previousVertex.position);
        } else {
          pos = joinedVertex.position.clone().rotateAround(Math.PI, previousVertex.position);
        }
        vertex.previousPosition = previousVertex.position;
        vertex.setPositionFromVector(pos);
        vertex.positioned = true;
      } else {
        const v = new Vector2(this.opts.bondLength, 0);
        v.rotate(angle);
        v.add(previousVertex.position);
        vertex.setPositionFromVector(v);
        vertex.previousPosition = previousVertex.position;
        vertex.positioned = true;
      }
    }
    if (vertex.value.bridgedRing !== null) {
      const nextRing = this.getRing(vertex.value.bridgedRing);
      if (!nextRing.positioned) {
        const nextCenter = Vector2.subtract(
          vertex.previousPosition,
          vertex.position
        );
        nextCenter.invert();
        nextCenter.normalize();
        const r = MathHelper.polyCircumradius(
          this.opts.bondLength,
          nextRing.members.length
        );
        nextCenter.multiplyScalar(r);
        nextCenter.add(vertex.position);
        this.createRing(nextRing, nextCenter, vertex);
      }
    } else if (vertex.value.rings.length > 0) {
      const nextRing = this.getRing(vertex.value.rings[0]);
      if (!nextRing.positioned) {
        const nextCenter = Vector2.subtract(
          vertex.previousPosition,
          vertex.position
        );
        nextCenter.invert();
        nextCenter.normalize();
        const r = MathHelper.polyCircumradius(
          this.opts.bondLength,
          nextRing.getSize()
        );
        nextCenter.multiplyScalar(r);
        nextCenter.add(vertex.position);
        this.createRing(nextRing, nextCenter, vertex);
      }
    } else {
      const isStereoCenter = vertex.value.isStereoCenter;
      const tmpNeighbours = vertex.getNeighbours();
      let neighbours = [];
      for (let i = 0; i < tmpNeighbours.length; i++) {
        if (this.graph.vertices[tmpNeighbours[i]].value.isDrawn) {
          neighbours.push(tmpNeighbours[i]);
        }
      }
      if (previousVertex) {
        neighbours = ArrayHelper.remove(neighbours, previousVertex.id);
      }
      const previousAngle = vertex.getAngle();
      if (neighbours.length === 1) {
        const nextVertex = this.graph.vertices[neighbours[0]];
        if (vertex.value.bondType === "#" || previousVertex && previousVertex.value.bondType === "#" || vertex.value.bondType === "=" && previousVertex && previousVertex.value.rings.length === 0 && previousVertex.value.bondType === "=" && vertex.value.branchBond !== "-") {
          vertex.value.drawExplicit = false;
          if (previousVertex) {
            const straightEdge1 = this.graph.getEdge(
              vertex.id,
              previousVertex.id
            );
            straightEdge1.center = true;
          }
          const straightEdge2 = this.graph.getEdge(vertex.id, nextVertex.id);
          straightEdge2.center = true;
          if (vertex.value.bondType === "#" || previousVertex && previousVertex.value.bondType === "#") {
            nextVertex.angle = 0;
          }
          nextVertex.drawExplicit = true;
          this.createNextBond(
            nextVertex,
            vertex,
            previousAngle + nextVertex.angle
          );
        } else if (previousVertex && previousVertex.value.rings.length > 0) {
          const proposedAngleA = MathHelper.toRad(60);
          const proposedAngleB = -proposedAngleA;
          const proposedVectorA = new Vector2(this.opts.bondLength, 0);
          const proposedVectorB = new Vector2(this.opts.bondLength, 0);
          proposedVectorA.rotate(proposedAngleA).add(vertex.position);
          proposedVectorB.rotate(proposedAngleB).add(vertex.position);
          const centerOfMass = this.getCurrentCenterOfMass();
          const distanceA = proposedVectorA.distanceSq(centerOfMass);
          const distanceB = proposedVectorB.distanceSq(centerOfMass);
          nextVertex.angle = distanceA < distanceB ? proposedAngleB : proposedAngleA;
          this.createNextBond(
            nextVertex,
            vertex,
            previousAngle + nextVertex.angle
          );
        } else {
          let a = vertex.angle;
          if (previousVertex && previousVertex.neighbours.length > 3) {
            if (a > 0) {
              a = Math.min(1.0472, a);
            } else if (a < 0) {
              a = Math.max(-1.0472, a);
            } else {
              a = 1.0472;
            }
          } else if (!a) {
            const v = this.getLastVertexWithAngle(vertex.id);
            a = v.angle;
            if (!a) {
              a = 1.0472;
            }
          }
          if (previousVertex && !doubleBondConfigSet) {
            const bondType = this.graph.getEdge(
              vertex.id,
              nextVertex.id
            ).bondType;
            if (bondType === "/") {
              if (this.doubleBondConfig === "/") {
              } else if (this.doubleBondConfig === "\\") {
                a = -a;
              }
              this.doubleBondConfig = null;
            } else if (bondType === "\\") {
              if (this.doubleBondConfig === "/") {
                a = -a;
              } else if (this.doubleBondConfig === "\\") {
              }
              this.doubleBondConfig = null;
            }
          }
          if (originShortest) {
            nextVertex.angle = a;
          } else {
            nextVertex.angle = -a;
          }
          this.createNextBond(
            nextVertex,
            vertex,
            previousAngle + nextVertex.angle
          );
        }
      } else if (neighbours.length === 2) {
        let a = vertex.angle;
        if (!a) {
          a = 1.0472;
        }
        const subTreeDepthA = this.graph.getTreeDepth(neighbours[0], vertex.id);
        const subTreeDepthB = this.graph.getTreeDepth(neighbours[1], vertex.id);
        const l = this.graph.vertices[neighbours[0]];
        const r = this.graph.vertices[neighbours[1]];
        l.value.subtreeDepth = subTreeDepthA;
        r.value.subtreeDepth = subTreeDepthB;
        const subTreeDepthC = this.graph.getTreeDepth(
          previousVertex ? previousVertex.id : null,
          vertex.id
        );
        if (previousVertex) {
          previousVertex.value.subtreeDepth = subTreeDepthC;
        }
        let cis = 0;
        let trans = 1;
        if (r.value.element === "C" && l.value.element !== "C" && subTreeDepthB > 1 && subTreeDepthA < 5) {
          cis = 1;
          trans = 0;
        } else if (r.value.element !== "C" && l.value.element === "C" && subTreeDepthA > 1 && subTreeDepthB < 5) {
          cis = 0;
          trans = 1;
        } else if (subTreeDepthB > subTreeDepthA) {
          cis = 1;
          trans = 0;
        }
        const cisVertex = this.graph.vertices[neighbours[cis]];
        const transVertex = this.graph.vertices[neighbours[trans]];
        const edgeCis = this.graph.getEdge(vertex.id, cisVertex.id);
        const edgeTrans = this.graph.getEdge(vertex.id, transVertex.id);
        let originShortest2 = false;
        if (subTreeDepthC < subTreeDepthA && subTreeDepthC < subTreeDepthB) {
          originShortest2 = true;
        }
        transVertex.angle = a;
        cisVertex.angle = -a;
        if (this.doubleBondConfig === "\\") {
          if (transVertex.value.branchBond === "\\") {
            transVertex.angle = -a;
            cisVertex.angle = a;
          }
        } else if (this.doubleBondConfig === "/") {
          if (transVertex.value.branchBond === "/") {
            transVertex.angle = -a;
            cisVertex.angle = a;
          }
        }
        this.createNextBond(
          transVertex,
          vertex,
          previousAngle + transVertex.angle,
          originShortest2
        );
        this.createNextBond(
          cisVertex,
          vertex,
          previousAngle + cisVertex.angle,
          originShortest2
        );
      } else if (neighbours.length === 3) {
        const d1 = this.graph.getTreeDepth(neighbours[0], vertex.id);
        const d2 = this.graph.getTreeDepth(neighbours[1], vertex.id);
        const d3 = this.graph.getTreeDepth(neighbours[2], vertex.id);
        let s = this.graph.vertices[neighbours[0]];
        let l = this.graph.vertices[neighbours[1]];
        let r = this.graph.vertices[neighbours[2]];
        s.value.subtreeDepth = d1;
        l.value.subtreeDepth = d2;
        r.value.subtreeDepth = d3;
        if (d2 > d1 && d2 > d3) {
          s = this.graph.vertices[neighbours[1]];
          l = this.graph.vertices[neighbours[0]];
          r = this.graph.vertices[neighbours[2]];
        } else if (d3 > d1 && d3 > d2) {
          s = this.graph.vertices[neighbours[2]];
          l = this.graph.vertices[neighbours[0]];
          r = this.graph.vertices[neighbours[1]];
        }
        if (previousVertex && previousVertex.value.rings.length < 1 && s.value.rings.length < 1 && l.value.rings.length < 1 && r.value.rings.length < 1 && this.graph.getTreeDepth(l.id, vertex.id) === 1 && this.graph.getTreeDepth(r.id, vertex.id) === 1 && this.graph.getTreeDepth(s.id, vertex.id) > 1) {
          s.angle = -vertex.angle;
          if (vertex.angle >= 0) {
            l.angle = MathHelper.toRad(30);
            r.angle = MathHelper.toRad(90);
          } else {
            l.angle = -MathHelper.toRad(30);
            r.angle = -MathHelper.toRad(90);
          }
          this.createNextBond(s, vertex, previousAngle + s.angle);
          this.createNextBond(l, vertex, previousAngle + l.angle);
          this.createNextBond(r, vertex, previousAngle + r.angle);
        } else {
          s.angle = 0;
          l.angle = MathHelper.toRad(90);
          r.angle = -MathHelper.toRad(90);
          this.createNextBond(s, vertex, previousAngle + s.angle);
          this.createNextBond(l, vertex, previousAngle + l.angle);
          this.createNextBond(r, vertex, previousAngle + r.angle);
        }
      } else if (neighbours.length === 4) {
        const d1 = this.graph.getTreeDepth(neighbours[0], vertex.id);
        const d2 = this.graph.getTreeDepth(neighbours[1], vertex.id);
        const d3 = this.graph.getTreeDepth(neighbours[2], vertex.id);
        const d4 = this.graph.getTreeDepth(neighbours[3], vertex.id);
        let w = this.graph.vertices[neighbours[0]];
        let x = this.graph.vertices[neighbours[1]];
        let y = this.graph.vertices[neighbours[2]];
        let z = this.graph.vertices[neighbours[3]];
        w.value.subtreeDepth = d1;
        x.value.subtreeDepth = d2;
        y.value.subtreeDepth = d3;
        z.value.subtreeDepth = d4;
        if (d2 > d1 && d2 > d3 && d2 > d4) {
          w = this.graph.vertices[neighbours[1]];
          x = this.graph.vertices[neighbours[0]];
          y = this.graph.vertices[neighbours[2]];
          z = this.graph.vertices[neighbours[3]];
        } else if (d3 > d1 && d3 > d2 && d3 > d4) {
          w = this.graph.vertices[neighbours[2]];
          x = this.graph.vertices[neighbours[0]];
          y = this.graph.vertices[neighbours[1]];
          z = this.graph.vertices[neighbours[3]];
        } else if (d4 > d1 && d4 > d2 && d4 > d3) {
          w = this.graph.vertices[neighbours[3]];
          x = this.graph.vertices[neighbours[0]];
          y = this.graph.vertices[neighbours[1]];
          z = this.graph.vertices[neighbours[2]];
        }
        w.angle = -MathHelper.toRad(36);
        x.angle = MathHelper.toRad(36);
        y.angle = -MathHelper.toRad(108);
        z.angle = MathHelper.toRad(108);
        this.createNextBond(w, vertex, previousAngle + w.angle);
        this.createNextBond(x, vertex, previousAngle + x.angle);
        this.createNextBond(y, vertex, previousAngle + y.angle);
        this.createNextBond(z, vertex, previousAngle + z.angle);
      }
    }
  }
  /**
   * Gets the vetex sharing the edge that is the common bond of two rings.
   *
   * @param {Vertex} vertex A vertex.
   * @returns {(Number|null)} The id of a vertex sharing the edge that is the common bond of two rings with the vertex provided or null, if none.
   */
  getCommonRingbondNeighbour(vertex) {
    const neighbours = vertex.neighbours;
    for (let i = 0; i < neighbours.length; i++) {
      const neighbour = this.graph.vertices[neighbours[i]];
      if (ArrayHelper.containsAll(neighbour.value.rings, vertex.value.rings)) {
        return neighbour;
      }
    }
    return null;
  }
  /**
   * Check if a vector is inside any ring.
   *
   * @param {Vector2} vec A vector.
   * @returns {Boolean} A boolean indicating whether or not the point (vector) is inside any of the rings associated with the current molecule.
   */
  isPointInRing(vec) {
    for (let i = 0; i < this.rings.length; i++) {
      const ring = this.rings[i];
      if (!ring.positioned) {
        continue;
      }
      const radius = MathHelper.polyCircumradius(
        this.opts.bondLength,
        ring.getSize()
      );
      const radiusSq = radius * radius;
      if (vec.distanceSq(ring.center) < radiusSq) {
        return true;
      }
    }
    return false;
  }
  /**
   * Check whether or not an edge is part of a ring.
   *
   * @param {Edge} edge An edge.
   * @returns {Boolean} A boolean indicating whether or not the edge is part of a ring.
   */
  isEdgeInRing(edge) {
    const source = this.graph.vertices[edge.sourceId];
    const target = this.graph.vertices[edge.targetId];
    return this.areVerticesInSameRing(source, target);
  }
  /**
   * Check whether or not an edge is rotatable.
   *
   * @param {Edge} edge An edge.
   * @returns {Boolean} A boolean indicating whether or not the edge is rotatable.
   */
  isEdgeRotatable(edge) {
    const vertexA = this.graph.vertices[edge.sourceId];
    const vertexB = this.graph.vertices[edge.targetId];
    if (edge.bondType !== "-") {
      return false;
    }
    if (vertexA.isTerminal() || vertexB.isTerminal()) {
      return false;
    }
    if (vertexA.value.rings.length > 0 && vertexB.value.rings.length > 0 && this.areVerticesInSameRing(vertexA, vertexB)) {
      return false;
    }
    return true;
  }
  /**
   * Check whether or not a ring is an implicitly defined aromatic ring (lower case smiles).
   *
   * @param {Ring} ring A ring.
   * @returns {Boolean} A boolean indicating whether or not a ring is implicitly defined as aromatic.
   */
  isRingAromatic(ring) {
    for (let i = 0; i < ring.members.length; i++) {
      const vertex = this.graph.vertices[ring.members[i]];
      if (!vertex.value.isPartOfAromaticRing) {
        return false;
      }
    }
    return true;
  }
  /**
   * Get the normals of an edge.
   *
   * @param {Edge} edge An edge.
   * @returns {Vector2[]} An array containing two vectors, representing the normals.
   */
  getEdgeNormals(edge) {
    const v1 = this.graph.vertices[edge.sourceId].position;
    const v2 = this.graph.vertices[edge.targetId].position;
    const normals = Vector2.units(v1, v2);
    return normals;
  }
  /**
   * Returns an array of vertices that are neighbouring a vertix but are not members of a ring (including bridges).
   *
   * @param {Number} vertexId A vertex id.
   * @returns {Vertex[]} An array of vertices.
   */
  getNonRingNeighbours(vertexId) {
    const nrneighbours = [];
    const vertex = this.graph.vertices[vertexId];
    const neighbours = vertex.neighbours;
    for (let i = 0; i < neighbours.length; i++) {
      const neighbour = this.graph.vertices[neighbours[i]];
      const nIntersections = ArrayHelper.intersection(
        vertex.value.rings,
        neighbour.value.rings
      ).length;
      if (nIntersections === 0 && neighbour.value.isBridge === false) {
        nrneighbours.push(neighbour);
      }
    }
    return nrneighbours;
  }
  /**
   * Annotaed stereochemistry information for visualization.
   */
  annotateStereochemistry() {
    const maxDepth = 10;
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      if (!vertex.value.isStereoCenter) {
        continue;
      }
      const neighbours = vertex.getNeighbours();
      const nNeighbours = neighbours.length;
      const priorities = Array(nNeighbours);
      for (let j = 0; j < nNeighbours; j++) {
        const visited = new Uint8Array(this.graph.vertices.length);
        const priority = Array([]);
        visited[vertex.id] = 1;
        this.visitStereochemistry(
          neighbours[j],
          vertex.id,
          visited,
          priority,
          maxDepth,
          0
        );
        for (let k = 0; k < priority.length; k++) {
          priority[k].sort(function(a, b) {
            return b - a;
          });
        }
        priorities[j] = [j, priority];
      }
      let maxLevels = 0;
      let maxEntries = 0;
      for (let j = 0; j < priorities.length; j++) {
        if (priorities[j][1].length > maxLevels) {
          maxLevels = priorities[j][1].length;
        }
        for (let k = 0; k < priorities[j][1].length; k++) {
          if (priorities[j][1][k].length > maxEntries) {
            maxEntries = priorities[j][1][k].length;
          }
        }
      }
      for (let j = 0; j < priorities.length; j++) {
        const diff = maxLevels - priorities[j][1].length;
        for (let k = 0; k < diff; k++) {
          priorities[j][1].push([]);
        }
        priorities[j][1].push([neighbours[j]]);
        for (let k = 0; k < priorities[j][1].length; k++) {
          const diff2 = maxEntries - priorities[j][1][k].length;
          for (let l = 0; l < diff2; l++) {
            priorities[j][1][k].push(0);
          }
        }
      }
      priorities.sort(function(a, b) {
        for (let j = 0; j < a[1].length; j++) {
          for (let k = 0; k < a[1][j].length; k++) {
            if (a[1][j][k] > b[1][j][k]) {
              return -1;
            } else if (a[1][j][k] < b[1][j][k]) {
              return 1;
            }
          }
        }
        return 0;
      });
      const order = new Uint8Array(nNeighbours);
      for (let j = 0; j < nNeighbours; j++) {
        order[j] = priorities[j][0];
        vertex.value.priority = j;
      }
      const posA = this.graph.vertices[neighbours[order[0]]].position;
      const posB = this.graph.vertices[neighbours[order[1]]].position;
      const posC = this.graph.vertices[neighbours[order[2]]].position;
      const cwA = posA.relativeClockwise(posB, vertex.position);
      const cwB = posA.relativeClockwise(posC, vertex.position);
      const isCw = cwA === -1;
      const rotation = vertex.value.bracket.chirality === "@" ? -1 : 1;
      const rs = MathHelper.parityOfPermutation(order) * rotation === 1 ? "R" : "S";
      let wedgeA = "down";
      let wedgeB = "up";
      if (isCw && rs !== "R" || !isCw && rs !== "S") {
        vertex.value.hydrogenDirection = "up";
        wedgeA = "up";
        wedgeB = "down";
      }
      if (vertex.value.hasHydrogen) {
        this.graph.getEdge(
          vertex.id,
          neighbours[order[order.length - 1]]
        ).wedge = wedgeA;
      }
      const wedgeOrder = new Array(neighbours.length - 1);
      const showHydrogen = vertex.value.rings.length > 1 && vertex.value.hasHydrogen;
      const offset = vertex.value.hasHydrogen ? 1 : 0;
      for (let j = 0; j < order.length - offset; j++) {
        wedgeOrder[j] = new Uint32Array(2);
        const neighbour = this.graph.vertices[neighbours[order[j]]];
        wedgeOrder[j][0] += neighbour.value.isStereoCenter ? 0 : 1e5;
        wedgeOrder[j][0] += this.areVerticesInSameRing(neighbour, vertex) ? 0 : 1e4;
        wedgeOrder[j][0] += neighbour.value.isHeteroAtom() ? 1e3 : 0;
        wedgeOrder[j][0] -= neighbour.value.subtreeDepth === 0 ? 1e3 : 0;
        wedgeOrder[j][0] += 1e3 - neighbour.value.subtreeDepth;
        wedgeOrder[j][1] = neighbours[order[j]];
      }
      wedgeOrder.sort(function(a, b) {
        if (a[0] > b[0]) {
          return -1;
        } else if (a[0] < b[0]) {
          return 1;
        }
        return 0;
      });
      if (!showHydrogen) {
        const wedgeId = wedgeOrder[0][1];
        if (vertex.value.hasHydrogen) {
          this.graph.getEdge(vertex.id, wedgeId).wedge = wedgeB;
        } else {
          let wedge = wedgeB;
          for (let j = order.length - 1; j >= 0; j--) {
            if (wedge === wedgeA) {
              wedge = wedgeB;
            } else {
              wedge = wedgeA;
            }
            if (neighbours[order[j]] === wedgeId) {
              break;
            }
          }
          this.graph.getEdge(vertex.id, wedgeId).wedge = wedge;
        }
      }
      vertex.value.chirality = rs;
    }
  }
  /**
   *
   *
   * @param {Number} vertexId The id of a vertex.
   * @param {(Number|null)} previousVertexId The id of the parent vertex of the vertex.
   * @param {Uint8Array} visited An array containing the visited flag for all vertices in the graph.
   * @param {Array} priority An array of arrays storing the atomic numbers for each level.
   * @param {Number} maxDepth The maximum depth.
   * @param {Number} depth The current depth.
   */
  visitStereochemistry(vertexId, previousVertexId, visited, priority, maxDepth, depth, parentAtomicNumber = 0) {
    visited[vertexId] = 1;
    const vertex = this.graph.vertices[vertexId];
    const atomicNumber = vertex.value.getAtomicNumber();
    if (priority.length <= depth) {
      priority.push([]);
    }
    for (let i = 0; i < this.graph.getEdge(vertexId, previousVertexId).weight; i++) {
      priority[depth].push(parentAtomicNumber * 1e3 + atomicNumber);
    }
    const neighbours = this.graph.vertices[vertexId].neighbours;
    for (let i = 0; i < neighbours.length; i++) {
      if (visited[neighbours[i]] !== 1 && depth < maxDepth - 1) {
        this.visitStereochemistry(
          neighbours[i],
          vertexId,
          visited.slice(),
          priority,
          maxDepth,
          depth + 1,
          atomicNumber
        );
      }
    }
    if (depth < maxDepth - 1) {
      let bonds = 0;
      for (let i = 0; i < neighbours.length; i++) {
        bonds += this.graph.getEdge(vertexId, neighbours[i]).weight;
      }
      for (let i = 0; i < vertex.value.getMaxBonds() - bonds; i++) {
        if (priority.length <= depth + 1) {
          priority.push([]);
        }
        priority[depth + 1].push(atomicNumber * 1e3 + 1);
      }
    }
  }
  /**
   * Creates pseudo-elements (such as Et, Me, Ac, Bz, ...) at the position of the carbon sets
   * the involved atoms not to be displayed.
   */
  initPseudoElements() {
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      const neighbourIds = vertex.neighbours;
      const neighbours = Array(neighbourIds.length);
      for (let j = 0; j < neighbourIds.length; j++) {
        neighbours[j] = this.graph.vertices[neighbourIds[j]];
      }
      if (vertex.getNeighbourCount() < 3 || vertex.value.rings.length > 0) {
        continue;
      }
      if (vertex.value.element === "P") {
        continue;
      }
      if (vertex.value.element === "C" && neighbours.length === 3 && neighbours[0].value.element === "N" && neighbours[1].value.element === "N" && neighbours[2].value.element === "N") {
        continue;
      }
      let heteroAtomCount = 0;
      let ctn = 0;
      for (let j = 0; j < neighbours.length; j++) {
        const neighbour = neighbours[j];
        const neighbouringElement = neighbour.value.element;
        const neighbourCount = neighbour.getNeighbourCount();
        if (neighbouringElement !== "C" && neighbouringElement !== "H" && neighbourCount === 1) {
          heteroAtomCount++;
        }
        if (neighbourCount > 1) {
          ctn++;
        }
      }
      if (ctn > 1 || heteroAtomCount < 2) {
        continue;
      }
      let previous = null;
      for (let j = 0; j < neighbours.length; j++) {
        const neighbour = neighbours[j];
        if (neighbour.getNeighbourCount() > 1) {
          previous = neighbour;
        }
      }
      for (let j = 0; j < neighbours.length; j++) {
        const neighbour = neighbours[j];
        if (neighbour.getNeighbourCount() > 1) {
          continue;
        }
        neighbour.value.isDrawn = false;
        let hydrogens = Atom.maxBonds[neighbour.value.element] - neighbour.value.bondCount;
        let charge = "";
        if (neighbour.value.bracket) {
          hydrogens = neighbour.value.bracket.hcount;
          charge = neighbour.value.bracket.charge || 0;
        }
        vertex.value.attachPseudoElement(
          neighbour.value.element,
          previous ? previous.value.element : null,
          hydrogens,
          charge
        );
      }
    }
    for (let i = 0; i < this.graph.vertices.length; i++) {
      const vertex = this.graph.vertices[i];
      const atom = vertex.value;
      const element = atom.element;
      if (element === "C" || element === "H" || !atom.isDrawn) {
        continue;
      }
      const neighbourIds = vertex.neighbours;
      const neighbours = Array(neighbourIds.length);
      for (let j = 0; j < neighbourIds.length; j++) {
        neighbours[j] = this.graph.vertices[neighbourIds[j]];
      }
      for (let j = 0; j < neighbours.length; j++) {
        const neighbour = neighbours[j].value;
        if (!neighbour.hasAttachedPseudoElements || neighbour.getAttachedPseudoElementsCount() !== 2) {
          continue;
        }
        const pseudoElements = neighbour.getAttachedPseudoElements();
        if (pseudoElements.hasOwnProperty("0O") && pseudoElements.hasOwnProperty("3C")) {
          neighbour.isDrawn = false;
          vertex.value.attachPseudoElement("Ac", "", 0);
        }
      }
    }
  }
};

// src/SvgWrapper.ts
function makeid(length) {
  let result = "";
  const characters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
var SvgWrapper = class _SvgWrapper {
  svg;
  container;
  opts;
  uid;
  gradientId;
  paths;
  vertices;
  gradients;
  highlights;
  drawingWidth;
  drawingHeight;
  halfBondThickness;
  themeManager;
  maskElements;
  maxX;
  maxY;
  minX;
  minY;
  style;
  constructor(themeManager, target, options, clear = true) {
    if (typeof target === "string") {
      this.svg = document.getElementById(target);
    } else {
      this.svg = target;
    }
    this.container = null;
    this.opts = options;
    this.uid = makeid(5);
    this.gradientId = 0;
    this.paths = [];
    this.vertices = [];
    this.gradients = [];
    this.highlights = [];
    this.drawingWidth = 0;
    this.drawingHeight = 0;
    this.halfBondThickness = this.opts.bondThickness / 2;
    this.themeManager = themeManager;
    this.maskElements = [];
    this.maxX = -Number.MAX_VALUE;
    this.maxY = -Number.MAX_VALUE;
    this.minX = Number.MAX_VALUE;
    this.minY = Number.MAX_VALUE;
    if (clear) {
      while (this.svg.firstChild) {
        this.svg.removeChild(this.svg.firstChild);
      }
    }
    this.style = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "style"
    );
    this.style.appendChild(
      document.createTextNode(`
                .element {
                    font: ${this.opts.fontSizeLarge}pt ${this.opts.fontFamily};
                }
                .sub {
                    font: ${this.opts.fontSizeSmall}pt ${this.opts.fontFamily};
                }
            `)
    );
    if (this.svg) {
      this.svg.appendChild(this.style);
    } else {
      this.container = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "g"
      );
      this.container.appendChild(this.style);
    }
  }
  constructSvg() {
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), masks = document.createElementNS("http://www.w3.org/2000/svg", "mask"), highlights = document.createElementNS("http://www.w3.org/2000/svg", "g"), paths = document.createElementNS("http://www.w3.org/2000/svg", "g"), vertices = document.createElementNS("http://www.w3.org/2000/svg", "g"), pathChildNodes = this.paths;
    const mask = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    mask.setAttributeNS(null, "x", String(this.minX));
    mask.setAttributeNS(null, "y", String(this.minY));
    mask.setAttributeNS(null, "width", String(this.maxX - this.minX));
    mask.setAttributeNS(null, "height", String(this.maxY - this.minY));
    mask.setAttributeNS(null, "fill", "white");
    masks.appendChild(mask);
    masks.setAttributeNS(null, "id", this.uid + "-text-mask");
    for (const path of pathChildNodes) {
      paths.appendChild(path);
    }
    for (const highlight of this.highlights) {
      highlights.appendChild(highlight);
    }
    for (const vertex of this.vertices) {
      vertices.appendChild(vertex);
    }
    for (const mask2 of this.maskElements) {
      masks.appendChild(mask2);
    }
    for (const gradient of this.gradients) {
      defs.appendChild(gradient);
    }
    paths.setAttributeNS(null, "mask", "url(#" + this.uid + "-text-mask)");
    this.updateViewbox(this.opts.scale);
    if (this.svg) {
      this.svg.appendChild(defs);
      this.svg.appendChild(masks);
      this.svg.appendChild(highlights);
      this.svg.appendChild(paths);
      this.svg.appendChild(vertices);
    } else {
      this.container.appendChild(defs);
      this.container.appendChild(masks);
      this.container.appendChild(paths);
      this.container.appendChild(vertices);
      return this.container;
    }
  }
  /**
   * Create a linear gradient to apply to a line
   *
   * @param {Line} line the line to apply the gradiation to.
   */
  createGradient(line) {
    const gradient = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "linearGradient"
    ), gradientUrl = this.uid + `-line-${this.gradientId++}`, l = line.getLeftVector(), r = line.getRightVector(), fromX = l.x, fromY = l.y, toX = r.x, toY = r.y;
    gradient.setAttributeNS(null, "id", gradientUrl);
    gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
    gradient.setAttributeNS(null, "x1", String(fromX));
    gradient.setAttributeNS(null, "y1", String(fromY));
    gradient.setAttributeNS(null, "x2", String(toX));
    gradient.setAttributeNS(null, "y2", String(toY));
    const firstStop = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "stop"
    );
    firstStop.setAttributeNS(
      null,
      "stop-color",
      this.themeManager.getColor(line.getLeftElement()) || this.themeManager.getColor("C")
    );
    firstStop.setAttributeNS(null, "offset", "20%");
    const secondStop = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "stop"
    );
    secondStop.setAttributeNS(
      null,
      "stop-color",
      this.themeManager.getColor(
        line.getRightElement() || this.themeManager.getColor("C")
      )
    );
    secondStop.setAttributeNS(null, "offset", "100%");
    gradient.appendChild(firstStop);
    gradient.appendChild(secondStop);
    this.gradients.push(gradient);
    return gradientUrl;
  }
  /**
   * Create a tspan element for sub or super scripts that styles the text
   * appropriately as one of those text types.
   *
   * @param {String} text the actual text
   * @param {String} shift the type of text, either 'sub', or 'super'
   */
  createSubSuperScripts(text, shift) {
    const elem = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "tspan"
    );
    elem.setAttributeNS(null, "baseline-shift", shift);
    elem.appendChild(document.createTextNode(text));
    elem.setAttributeNS(null, "class", "sub");
    return elem;
  }
  static createUnicodeCharge(n) {
    if (n === 1) {
      return "\u207A";
    }
    if (n === -1) {
      return "\u207B";
    }
    if (n > 1) {
      return _SvgWrapper.createUnicodeSuperscript(n) + "\u207A";
    }
    if (n < -1) {
      return _SvgWrapper.createUnicodeSuperscript(n) + "\u207B";
    }
    return "";
  }
  /**
   * Determine drawing dimensiosn based on vertex positions.
   *
   * @param {Vertex[]} vertices An array of vertices containing the vertices associated with the current molecule.
   */
  determineDimensions(vertices) {
    for (let i = 0; i < vertices.length; i++) {
      if (!vertices[i].value.isDrawn) {
        continue;
      }
      const p = vertices[i].position;
      if (this.maxX < p.x) {
        this.maxX = p.x;
      }
      if (this.maxY < p.y) {
        this.maxY = p.y;
      }
      if (this.minX > p.x) {
        this.minX = p.x;
      }
      if (this.minY > p.y) {
        this.minY = p.y;
      }
    }
    const padding = this.opts.padding;
    this.maxX += padding;
    this.maxY += padding;
    this.minX -= padding;
    this.minY -= padding;
    this.drawingWidth = this.maxX - this.minX;
    this.drawingHeight = this.maxY - this.minY;
  }
  updateViewbox(scale) {
    let x = this.minX;
    let y = this.minY;
    let width = this.maxX - this.minX;
    let height = this.maxY - this.minY;
    if (scale <= 0) {
      if (width > height) {
        const diff = width - height;
        height = width;
        y -= diff / 2;
      } else {
        const diff = height - width;
        width = height;
        x -= diff / 2;
      }
    } else {
      if (this.svg) {
        this.svg.style.width = scale * width + "px";
        this.svg.style.height = scale * height + "px";
      }
    }
    this.svg.setAttributeNS(null, "viewBox", `${x} ${y} ${width} ${height}`);
  }
  /**
   * Draw an svg ellipse as a ball.
   *
   * @param {Number} x The x position of the text.
   * @param {Number} y The y position of the text.
   * @param {String} elementName The name of the element (single-letter).
   */
  drawBall(x, y, elementName) {
    const r = this.opts.bondLength / 4.5;
    if (x - r < this.minX) {
      this.minX = x - r;
    }
    if (x + r > this.maxX) {
      this.maxX = x + r;
    }
    if (y - r < this.minY) {
      this.minY = y - r;
    }
    if (y + r > this.maxY) {
      this.maxY = y + r;
    }
    const ball = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    ball.setAttributeNS(null, "cx", String(x));
    ball.setAttributeNS(null, "cy", String(y));
    ball.setAttributeNS(null, "r", String(r));
    ball.setAttributeNS(null, "fill", this.themeManager.getColor(elementName));
    this.vertices.push(ball);
  }
  /**
   * @param {Line} line the line object to create the wedge from
   */
  drawWedge(line) {
    const l = line.getLeftVector().clone(), r = line.getRightVector().clone();
    const normals = Vector2.normals(l, r);
    normals[0].normalize();
    normals[1].normalize();
    const isRightChiralCenter = line.getRightChiral();
    let start = l, end = r;
    if (isRightChiralCenter) {
      start = r;
      end = l;
    }
    const t = Vector2.add(
      start,
      Vector2.multiplyScalar(normals[0], this.halfBondThickness)
    ), u = Vector2.add(
      end,
      Vector2.multiplyScalar(normals[0], 3 + this.opts.fontSizeLarge / 4)
    ), v = Vector2.add(
      end,
      Vector2.multiplyScalar(normals[1], 3 + this.opts.fontSizeLarge / 4)
    ), w = Vector2.add(
      start,
      Vector2.multiplyScalar(normals[1], this.halfBondThickness)
    );
    const polygon = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "polygon"
    ), gradient = this.createGradient(line, l.x, l.y, r.x, r.y);
    polygon.setAttributeNS(
      null,
      "points",
      `${t.x},${t.y} ${u.x},${u.y} ${v.x},${v.y} ${w.x},${w.y}`
    );
    polygon.setAttributeNS(null, "fill", `url('#${gradient}')`);
    this.paths.push(polygon);
  }
  /* Draw a highlight for an atom
   *
   *  @param {Number} x The x position of the highlight
   *  @param {Number} y The y position of the highlight
   *  @param {string} color The color of the highlight, default #03fc9d
   */
  drawAtomHighlight(x, y, color = "#03fc9d") {
    const ball = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    ball.setAttributeNS(null, "cx", String(x));
    ball.setAttributeNS(null, "cy", String(y));
    ball.setAttributeNS(null, "r", String(this.opts.bondLength / 3));
    ball.setAttributeNS(null, "fill", color);
    this.highlights.push(ball);
  }
  /**
   * Draw a dashed wedge on the canvas.
   *
   * @param {Line} line A line.
   */
  drawDashedWedge(line) {
    if (isNaN(line.from.x) || isNaN(line.from.y) || isNaN(line.to.x) || isNaN(line.to.y)) {
      return;
    }
    const l = line.getLeftVector().clone(), r = line.getRightVector().clone(), normals = Vector2.normals(l, r);
    normals[0].normalize();
    normals[1].normalize();
    let isRightChiralCenter = line.getRightChiral(), start, end;
    if (isRightChiralCenter) {
      start = r;
      end = l;
    } else {
      start = l;
      end = r;
    }
    const dir = Vector2.subtract(end, start).normalize(), length = line.getLength(), step = 1.25 / (length / (this.opts.bondLength / 10)), changed = false;
    const gradient = this.createGradient(line);
    for (let t = 0; t < 1; t += step) {
      const to = Vector2.multiplyScalar(dir, t * length), startDash = Vector2.add(start, to), width = this.opts.fontSizeLarge / 2 * t, dashOffset = Vector2.multiplyScalar(normals[0], width);
      startDash.subtract(dashOffset);
      const endDash = startDash.clone();
      endDash.add(Vector2.multiplyScalar(dashOffset, 2));
      this.drawLine(new Line(startDash, endDash), null, gradient);
    }
  }
  /**
   * Draws a debug dot at a given coordinate and adds text.
   *
   * @param {Number} x The x coordinate.
   * @param {Number} y The y coordindate.
   * @param {String} [debugText=''] A string.
   * @param {String} [color='#f00'] A color in hex form.
   */
  drawDebugPoint(x, y, debugText = "", color = "#f00") {
    const point = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    point.setAttributeNS(null, "cx", String(x));
    point.setAttributeNS(null, "cy", String(y));
    point.setAttributeNS(null, "r", "2");
    point.setAttributeNS(null, "fill", "#f00");
    this.vertices.push(point);
    this.drawDebugText(x, y, debugText);
  }
  /**
   * Draws a debug text message at a given position
   *
   * @param {Number} x The x coordinate.
   * @param {Number} y The y coordinate.
   * @param {String} text The debug text.
   */
  drawDebugText(x, y, text) {
    const textElem = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "text"
    );
    textElem.setAttributeNS(null, "x", String(x));
    textElem.setAttributeNS(null, "y", String(y));
    textElem.setAttributeNS(null, "class", "debug");
    textElem.setAttributeNS(null, "fill", "#ff0000");
    textElem.setAttributeNS(
      null,
      "style",
      `
                font: 5px Droid Sans, sans-serif;
            `
    );
    textElem.appendChild(document.createTextNode(text));
    this.vertices.push(textElem);
  }
  /**
   * Draws a ring.
   *
   * @param {x} x The x coordinate of the ring.
   * @param {y} r The y coordinate of the ring.
   * @param {s} s The size of the ring.
   */
  drawRing(x, y, s) {
    const circleElem = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    const radius = MathHelper.apothemFromSideLength(this.opts.bondLength, s);
    circleElem.setAttributeNS(null, "cx", String(x));
    circleElem.setAttributeNS(null, "cy", String(y));
    circleElem.setAttributeNS(
      null,
      "r",
      String(radius - this.opts.bondSpacing)
    );
    circleElem.setAttributeNS(null, "stroke", this.themeManager.getColor("C"));
    circleElem.setAttributeNS(null, "stroke-width", this.opts.bondThickness);
    circleElem.setAttributeNS(null, "fill", "none");
    this.paths.push(circleElem);
  }
  /**
   * Draws a line.
   *
   * @param {Line} line A line.
   * @param {Boolean} dashed defaults to false.
   * @param {String} gradient gradient url. Defaults to null.
   */
  drawLine(line, dashed = false, gradient = null, linecap = "round") {
    const opts = this.opts, stylesArr = [
      ["stroke-width", this.opts.bondThickness],
      ["stroke-linecap", linecap],
      ["stroke-dasharray", dashed ? "5, 5" : "none"]
    ], l = line.getLeftVector(), r = line.getRightVector(), fromX = l.x, fromY = l.y, toX = r.x, toY = r.y;
    const styles = stylesArr.map((sub) => sub.join(":")).join(";"), lineElem = document.createElementNS("http://www.w3.org/2000/svg", "line");
    lineElem.setAttributeNS(null, "x1", String(fromX));
    lineElem.setAttributeNS(null, "y1", String(fromY));
    lineElem.setAttributeNS(null, "x2", String(toX));
    lineElem.setAttributeNS(null, "y2", String(toY));
    lineElem.setAttributeNS(null, "style", styles);
    this.paths.push(lineElem);
    if (gradient === null) {
      gradient = this.createGradient(line, fromX, fromY, toX, toY);
    }
    lineElem.setAttributeNS(null, "stroke", `url('#${gradient}')`);
  }
  /**
   * Draw a point.
   *
   * @param {Number} x The x position of the point.
   * @param {Number} y The y position of the point.
   * @param {String} elementName The name of the element (single-letter).
   */
  drawPoint(x, y, elementName) {
    const r = 0.75;
    if (x - r < this.minX) {
      this.minX = x - r;
    }
    if (x + r > this.maxX) {
      this.maxX = x + r;
    }
    if (y - r < this.minY) {
      this.minY = y - r;
    }
    if (y + r > this.maxY) {
      this.maxY = y + r;
    }
    const mask = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    mask.setAttributeNS(null, "cx", String(x));
    mask.setAttributeNS(null, "cy", String(y));
    mask.setAttributeNS(null, "r", "1.5");
    mask.setAttributeNS(null, "fill", "black");
    this.maskElements.push(mask);
    const point = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    point.setAttributeNS(null, "cx", String(x));
    point.setAttributeNS(null, "cy", String(y));
    point.setAttributeNS(null, "r", String(r));
    point.setAttributeNS(null, "fill", this.themeManager.getColor(elementName));
    this.vertices.push(point);
  }
  /**
   * Draw a text to the canvas.
   *
   * @param {Number} x The x position of the text.
   * @param {Number} y The y position of the text.
   * @param {String} elementName The name of the element (single-letter).
   * @param {Number} hydrogens The number of hydrogen atoms.
   * @param {String} direction The direction of the text in relation to the associated vertex.
   * @param {Boolean} isTerminal A boolean indicating whether or not the vertex is terminal.
   * @param {Number} charge The charge of the atom.
   * @param {Number} isotope The isotope number.
   * @param {Number} totalVertices The total number of vertices in the graph.
   * @param {Object} attachedPseudoElement A map with containing information for pseudo elements or concatinated elements. The key is comprised of the element symbol and the hydrogen count.
   * @param {String} attachedPseudoElement.element The element symbol.
   * @param {Number} attachedPseudoElement.count The number of occurences that match the key.
   * @param {Number} attachedPseudoElement.hyrogenCount The number of hydrogens attached to each atom matching the key.
   */
  drawText(x, y, elementName, hydrogens, direction, isTerminal, charge, isotope, totalVertices, attachedPseudoElement = {}) {
    const text = [];
    let display = elementName;
    if (charge !== 0 && charge !== null) {
      display += _SvgWrapper.createUnicodeCharge(charge);
    }
    if (isotope !== 0 && isotope !== null) {
      display = _SvgWrapper.createUnicodeSuperscript(isotope) + display;
    }
    text.push([display, elementName]);
    if (hydrogens === 1) {
      text.push(["H", "H"]);
    } else if (hydrogens > 1) {
      text.push(["H" + _SvgWrapper.createUnicodeSubscript(hydrogens), "H"]);
    }
    if (charge === 1 && elementName === "N" && attachedPseudoElement.hasOwnProperty("0O") && attachedPseudoElement.hasOwnProperty("0O-1")) {
      attachedPseudoElement = {
        "0O": {
          element: "O",
          count: 2,
          hydrogenCount: 0,
          previousElement: "C",
          charge: ""
        }
      };
      charge = 0;
    }
    for (const key in attachedPseudoElement) {
      if (!attachedPseudoElement.hasOwnProperty(key)) {
        continue;
      }
      const pe = attachedPseudoElement[key];
      let display2 = pe.element;
      if (pe.count > 1) {
        display2 += _SvgWrapper.createUnicodeSubscript(pe.count);
      }
      if (pe.charge !== "") {
        display2 += _SvgWrapper.createUnicodeCharge(charge);
      }
      text.push([display2, pe.element]);
      if (pe.hydrogenCount === 1) {
        text.push(["H", "H"]);
      } else if (pe.hydrogenCount > 1) {
        text.push([
          "H" + _SvgWrapper.createUnicodeSubscript(pe.hydrogenCount),
          "H"
        ]);
      }
    }
    this.write(text, direction, x, y, totalVertices === 1);
  }
  write(text, direction, x, y, singleVertex) {
    const bbox = _SvgWrapper.measureText(
      text[0][1],
      this.opts.fontSizeLarge,
      this.opts.fontFamily
    );
    if (direction === "left" && text[0][0] !== text[0][1]) {
      bbox.width *= 2;
    }
    if (singleVertex) {
      if (x + bbox.width * text.length > this.maxX) {
        this.maxX = x + bbox.width * text.length;
      }
      if (x - bbox.width / 2 < this.minX) {
        this.minX = x - bbox.width / 2;
      }
      if (y - bbox.height < this.minY) {
        this.minY = y - bbox.height;
      }
      if (y + bbox.height > this.maxY) {
        this.maxY = y + bbox.height;
      }
    } else {
      if (direction !== "right") {
        if (x + bbox.width * text.length > this.maxX) {
          this.maxX = x + bbox.width * text.length;
        }
        if (x - bbox.width * text.length < this.minX) {
          this.minX = x - bbox.width * text.length;
        }
      } else if (direction !== "left") {
        if (x + bbox.width * text.length > this.maxX) {
          this.maxX = x + bbox.width * text.length;
        }
        if (x - bbox.width / 2 < this.minX) {
          this.minX = x - bbox.width / 2;
        }
      }
      if (y - bbox.height < this.minY) {
        this.minY = y - bbox.height;
      }
      if (y + bbox.height > this.maxY) {
        this.maxY = y + bbox.height;
      }
      if (direction === "down") {
        if (y + 0.8 * bbox.height * text.length > this.maxY) {
          this.maxY = y + 0.8 * bbox.height * text.length;
        }
      }
      if (direction === "up") {
        if (y - 0.8 * bbox.height * text.length < this.minY) {
          this.minY = y - 0.8 * bbox.height * text.length;
        }
      }
    }
    const cx = x;
    const cy = y;
    const textElem = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "text"
    );
    textElem.setAttributeNS(null, "class", "element");
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    textElem.setAttributeNS(null, "fill", "#ffffff");
    if (direction === "left") {
      text = text.reverse();
    }
    if (direction === "right" || direction === "down" || direction === "up") {
      x -= bbox.width / 2;
    }
    if (direction === "left") {
      x += bbox.width / 2;
    }
    text.forEach((part, i) => {
      const display = part[0];
      const elementName = part[1];
      const tspanElem = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "tspan"
      );
      tspanElem.setAttributeNS(
        null,
        "fill",
        this.themeManager.getColor(elementName)
      );
      tspanElem.textContent = display;
      if (direction === "up" || direction === "down") {
        tspanElem.setAttributeNS(null, "x", "0px");
        if (direction === "up") {
          tspanElem.setAttributeNS(null, "y", `-${0.9 * i}em`);
        } else {
          tspanElem.setAttributeNS(null, "y", `${0.9 * i}em`);
        }
      }
      textElem.appendChild(tspanElem);
    });
    textElem.setAttributeNS(null, "data-direction", direction);
    if (direction === "left" || direction === "right") {
      textElem.setAttributeNS(null, "dominant-baseline", "alphabetic");
      textElem.setAttributeNS(null, "y", "0.36em");
    } else {
      textElem.setAttributeNS(null, "dominant-baseline", "central");
    }
    if (direction === "left") {
      textElem.setAttributeNS(null, "text-anchor", "end");
    }
    g.appendChild(textElem);
    g.setAttributeNS(
      null,
      "style",
      `transform: translateX(${x}px) translateY(${y}px)`
    );
    let maskRadius = this.opts.fontSizeLarge * 0.75;
    if (text[0][1].length > 1) {
      maskRadius = this.opts.fontSizeLarge * 1.1;
    }
    const mask = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "circle"
    );
    mask.setAttributeNS(null, "cx", String(cx));
    mask.setAttributeNS(null, "cy", String(cy));
    mask.setAttributeNS(null, "r", String(maskRadius));
    mask.setAttributeNS(null, "fill", "black");
    this.maskElements.push(mask);
    this.vertices.push(g);
  }
  /**
   * Draw the wrapped SVG to a canvas.
   * @param {HTMLCanvasElement} canvas The canvas element to draw the svg to.
   */
  toCanvas(canvas, width, height) {
    if (typeof canvas === "string") {
      canvas = document.getElementById(canvas);
    }
    const image = new Image();
    image.onload = function() {
      canvas.width = width;
      canvas.height = height;
      canvas.getContext("2d").drawImage(image, 0, 0, width, height);
    };
    image.src = "data:image/svg+xml;charset-utf-8," + encodeURIComponent(this.svg.outerHTML);
  }
  static createUnicodeSubscript(n) {
    let result = "";
    n.toString().split("").forEach((d) => {
      result += ["\u2080", "\u2081", "\u2082", "\u2083", "\u2084", "\u2085", "\u2086", "\u2087", "\u2088", "\u2089"][parseInt(d)];
    });
    return result;
  }
  static createUnicodeSuperscript(n) {
    let result = "";
    n.toString().split("").forEach((d) => {
      result += ["\u2070", "\xB9", "\xB2", "\xB3", "\u2074", "\u2075", "\u2076", "\u2077", "\u2078", "\u2079"][parseInt(d)];
    });
    return result;
  }
  static replaceNumbersWithSubscript(text) {
    const subscriptNumbers = {
      0: "\u2080",
      1: "\u2081",
      2: "\u2082",
      3: "\u2083",
      4: "\u2084",
      5: "\u2085",
      6: "\u2086",
      7: "\u2087",
      8: "\u2088",
      9: "\u2089"
    };
    for (const [key, value] of Object.entries(subscriptNumbers)) {
      text = text.replaceAll(key, value);
    }
    return text;
  }
  static measureText(text, fontSize, fontFamily, lineHeight = 0.9) {
    const element = document.createElement("canvas");
    const ctx = element.getContext("2d");
    ctx.font = `${fontSize}pt ${fontFamily}`;
    const textMetrics = ctx.measureText(text);
    const compWidth = Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);
    return {
      width: textMetrics.width > compWidth ? textMetrics.width : compWidth,
      height: (Math.abs(textMetrics.actualBoundingBoxAscent) + Math.abs(textMetrics.actualBoundingBoxAscent)) * lineHeight
    };
  }
  /**
   * Convert an SVG to a canvas. Warning: This happens async!
   *
   * @param {SVGElement} svg
   * @param {HTMLCanvasElement} canvas
   * @param {Number} width
   * @param {Number} height
   * @param {CallableFunction} callback
   * @returns {HTMLCanvasElement} The input html canvas element after drawing to.
   */
  static svgToCanvas(svg, canvas, width, height, callback = null) {
    svg.setAttributeNS(null, "width", width);
    svg.setAttributeNS(null, "height", height);
    const image = new Image();
    image.onload = function() {
      canvas.width = width;
      canvas.height = height;
      const context = canvas.getContext("2d");
      context.imageSmoothingEnabled = false;
      context.drawImage(image, 0, 0, width, height);
      if (callback) {
        callback(canvas);
      }
    };
    image.onerror = function(err) {
      console.log(err);
    };
    image.src = "data:image/svg+xml;charset-utf-8," + encodeURIComponent(svg.outerHTML);
    return canvas;
  }
  /**
   * Convert an SVG to a canvas. Warning: This happens async!
   *
   * @param {SVGElement} svg
   * @param {HTMLImageElement} canvas
   * @param {Number} width
   * @param {Number} height
   */
  static svgToImg(svg, img, width, height) {
    const canvas = document.createElement("canvas");
    this.svgToCanvas(svg, canvas, width, height, (result) => {
      img.src = canvas.toDataURL("image/png");
    });
  }
  /**
   * Create an SVG element containing text.
   * @param {String} text
   * @param {*} themeManager
   * @param {*} options
   * @returns {{svg: SVGElement, width: Number, height: Number}} The SVG element containing the text and its dimensions.
   */
  static writeText(text, themeManager, fontSize, fontFamily, maxWidth = Number.MAX_SAFE_INTEGER) {
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const style = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "style"
    );
    style.appendChild(
      document.createTextNode(`
        .text {
            font: ${fontSize}pt ${fontFamily};
            dominant-baseline: ideographic;
        }
    `)
    );
    svg.appendChild(style);
    const textElem = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "text"
    );
    textElem.setAttributeNS(null, "class", "text");
    let maxLineWidth = 0;
    let totalHeight = 0;
    const lines = [];
    text.split("\n").forEach((line) => {
      const dims = _SvgWrapper.measureText(line, fontSize, fontFamily, 1);
      if (dims.width >= maxWidth) {
        let totalWordsWidth = 0;
        let maxWordsHeight = 0;
        const words = line.split(" ");
        let offset = 0;
        for (let i = 0; i < words.length; i++) {
          const wordDims = _SvgWrapper.measureText(
            words[i],
            fontSize,
            fontFamily,
            1
          );
          if (totalWordsWidth + wordDims.width > maxWidth) {
            lines.push({
              text: words.slice(offset, i).join(" "),
              width: totalWordsWidth,
              height: maxWordsHeight
            });
            totalWordsWidth = 0;
            maxWordsHeight = 0;
            offset = i;
          }
          if (wordDims.height > maxWordsHeight) {
            maxWordsHeight = wordDims.height;
          }
          totalWordsWidth += wordDims.width;
        }
        if (offset < words.length) {
          lines.push({
            text: words.slice(offset, words.length).join(" "),
            width: totalWordsWidth,
            height: maxWordsHeight
          });
        }
      } else {
        lines.push({
          text: line,
          width: dims.width,
          height: dims.height
        });
      }
    });
    lines.forEach((line, i) => {
      totalHeight += line.height;
      const tspanElem = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "tspan"
      );
      tspanElem.setAttributeNS(null, "fill", themeManager.getColor("C"));
      tspanElem.textContent = line.text;
      tspanElem.setAttributeNS(null, "x", "0px");
      tspanElem.setAttributeNS(null, "y", `${totalHeight}px`);
      textElem.appendChild(tspanElem);
      if (line.width > maxLineWidth) {
        maxLineWidth = line.width;
      }
    });
    svg.appendChild(textElem);
    return { svg, width: maxLineWidth, height: totalHeight };
  }
};

// src/SvgDrawer.ts
var SvgDrawer = class {
  preprocessor;
  opts;
  clear;
  svgWrapper;
  themeManager;
  svgDrawer;
  bridgedRing;
  constructor(options, clear = true) {
    this.preprocessor = new DrawerBase(options);
    this.opts = this.preprocessor.opts;
    this.clear = clear;
    this.svgWrapper = null;
  }
  /**
   * Draws the parsed smiles data to an svg element.
   *
   * @param {Object} data The tree returned by the smiles parser.
   * @param {(String|SVGElement)} target The id of the HTML svg element the structure is drawn to - or the element itself.
   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
   *
   * @returns {SVGElement} The svg element
   */
  draw(data, target, themeName = "light", infoOnly = false, highlight_atoms = []) {
    try {
      if (target === null || target === "svg") {
        target = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        target.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        target.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
        target.setAttributeNS(null, "width", this.opts.width);
        target.setAttributeNS(null, "height", this.opts.height);
      } else if (typeof target === "string") {
        target = document.getElementById(target);
      }
      const preprocessor = this.preprocessor;
      preprocessor.initDraw(data, themeName, infoOnly, highlight_atoms);
      if (!infoOnly) {
        this.themeManager = new ThemeManager(this.opts.themes, themeName);
        if (this.svgWrapper === null || this.clear) {
          this.svgWrapper = new SvgWrapper(
            this.themeManager,
            target,
            this.opts,
            this.clear
          );
        }
      }
      preprocessor.processGraph();
      this.svgWrapper.determineDimensions(preprocessor.graph.vertices);
      this.drawAtomHighlights(preprocessor.opts.debug);
      this.drawEdges(preprocessor.opts.debug);
      this.drawVertices(preprocessor.opts.debug);
      if (preprocessor.opts.debug) {
        console.log(preprocessor.graph);
        console.log(preprocessor.rings);
        console.log(preprocessor.ringConnections);
      }
      this.svgWrapper.constructSvg();
      return target;
    } catch (error) {
      throw new Error(`Error during drawing smiles:
${error} `);
    }
  }
  /**
   * Draws the parsed smiles data to a canvas element.
   *
   * @param {Object} data The tree returned by the smiles parser.
   * @param {(String|HTMLCanvasElement)} target The id of the HTML canvas element the structure is drawn to - or the element itself.
   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
   */
  drawCanvas(data, target, themeName = "light", infoOnly = false) {
    let canvas = null;
    if (typeof target === "string") {
      canvas = document.getElementById(target);
    } else {
      canvas = target;
    }
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttributeNS(null, "viewBox", "0 0 500 500");
    svg.setAttributeNS(null, "width", "500");
    svg.setAttributeNS(null, "height", "500");
    svg.setAttributeNS(
      null,
      "style",
      "visibility: hidden: position: absolute; left: -1000px"
    );
    document.body.appendChild(svg);
    this.svgDrawer.draw(data, svg, themeName, infoOnly);
    this.svgDrawer.svgWrapper.toCanvas(
      canvas,
      this.svgDrawer.opts.width,
      this.svgDrawer.opts.height
    );
    document.body.removeChild(svg);
    return target;
  }
  /**
   * Draws a ring inside a provided ring, indicating aromaticity.
   *
   * @param {Ring} ring A ring.
   */
  drawAromaticityRing(ring) {
    const svgWrapper = this.svgWrapper;
    svgWrapper.drawRing(ring.center.x, ring.center.y, ring.getSize());
  }
  /**
   * Draw the actual edges as bonds.
   *
   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
   */
  drawEdges(debug) {
    const preprocessor = this.preprocessor, graph = preprocessor.graph, rings = preprocessor.rings, drawn = Array(this.preprocessor.graph.edges.length);
    drawn.fill(false);
    graph.traverseBF(0, (vertex) => {
      const edges = graph.getEdges(vertex.id);
      for (let i = 0; i < edges.length; i++) {
        const edgeId = edges[i];
        if (!drawn[edgeId]) {
          drawn[edgeId] = true;
          this.drawEdge(edgeId, debug);
        }
      }
    });
    if (!this.bridgedRing) {
      for (let i = 0; i < rings.length; i++) {
        const ring = rings[i];
        if (preprocessor.isRingAromatic(ring)) {
          this.drawAromaticityRing(ring);
        }
      }
    }
  }
  /**
   * Draw the an edge as a bond.
   *
   * @param {Number} edgeId An edge id.
   * @param {Boolean} debug A boolean indicating whether or not to draw debug helpers.
   */
  drawEdge(edgeId, debug) {
    const preprocessor = this.preprocessor, opts = preprocessor.opts, svgWrapper = this.svgWrapper, edge = preprocessor.graph.edges[edgeId], vertexA = preprocessor.graph.vertices[edge.sourceId], vertexB = preprocessor.graph.vertices[edge.targetId], elementA = vertexA.value.element, elementB = vertexB.value.element;
    if ((!vertexA.value.isDrawn || !vertexB.value.isDrawn) && preprocessor.opts.atomVisualization === "default") {
      return;
    }
    const a = vertexA.position, b = vertexB.position, normals = preprocessor.getEdgeNormals(edge), sides = ArrayHelper.clone(normals);
    sides[0].multiplyScalar(10).add(a);
    sides[1].multiplyScalar(10).add(a);
    if (edge.bondType === "=" || preprocessor.getRingbondType(vertexA, vertexB) === "=" || edge.isPartOfAromaticRing && preprocessor.bridgedRing) {
      const inRing = preprocessor.areVerticesInSameRing(vertexA, vertexB);
      const s = preprocessor.chooseSide(vertexA, vertexB, sides);
      if (inRing) {
        const lcr = preprocessor.getLargestOrAromaticCommonRing(
          vertexA,
          vertexB
        );
        const center = lcr.center;
        normals[0].multiplyScalar(opts.bondSpacing);
        normals[1].multiplyScalar(opts.bondSpacing);
        let line = null;
        if (center.sameSideAs(
          vertexA.position,
          vertexB.position,
          Vector2.add(a, normals[0])
        )) {
          line = new Line(
            Vector2.add(a, normals[0]),
            Vector2.add(b, normals[0]),
            elementA,
            elementB
          );
        } else {
          line = new Line(
            Vector2.add(a, normals[1]),
            Vector2.add(b, normals[1]),
            elementA,
            elementB
          );
        }
        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
        if (edge.isPartOfAromaticRing) {
          svgWrapper.drawLine(line, true);
        } else {
          svgWrapper.drawLine(line);
        }
        svgWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (edge.center || vertexA.isTerminal() && vertexB.isTerminal() || s.anCount === 0 && s.bnCount > 1 || s.bnCount === 0 && s.anCount > 1) {
        this.multiplyNormals(normals, opts.halfBondSpacing);
        const lineA = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        ), lineB = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        svgWrapper.drawLine(lineA);
        svgWrapper.drawLine(lineB);
      } else if (s.sideCount[0] > s.sideCount[1] || s.totalSideCount[0] > s.totalSideCount[1]) {
        this.multiplyNormals(normals, opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[0]),
          Vector2.add(b, normals[0]),
          elementA,
          elementB
        );
        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
        svgWrapper.drawLine(line);
        svgWrapper.drawLine(new Line(a, b, elementA, elementB));
      } else if (s.sideCount[0] < s.sideCount[1] || s.totalSideCount[0] <= s.totalSideCount[1]) {
        this.multiplyNormals(normals, opts.bondSpacing);
        const line = new Line(
          Vector2.add(a, normals[1]),
          Vector2.add(b, normals[1]),
          elementA,
          elementB
        );
        line.shorten(opts.bondLength - opts.shortBondLength * opts.bondLength);
        svgWrapper.drawLine(line);
        svgWrapper.drawLine(new Line(a, b, elementA, elementB));
      }
    } else if (edge.bondType === "#") {
      normals[0].multiplyScalar(opts.bondSpacing / 1.5);
      normals[1].multiplyScalar(opts.bondSpacing / 1.5);
      const lineA = new Line(
        Vector2.add(a, normals[0]),
        Vector2.add(b, normals[0]),
        elementA,
        elementB
      );
      const lineB = new Line(
        Vector2.add(a, normals[1]),
        Vector2.add(b, normals[1]),
        elementA,
        elementB
      );
      svgWrapper.drawLine(lineA);
      svgWrapper.drawLine(lineB);
      svgWrapper.drawLine(new Line(a, b, elementA, elementB));
    } else if (edge.bondType === ".") {
    } else {
      const isChiralCenterA = vertexA.value.isStereoCenter;
      const isChiralCenterB = vertexB.value.isStereoCenter;
      if (edge.wedge === "up") {
        svgWrapper.drawWedge(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      } else if (edge.wedge === "down") {
        svgWrapper.drawDashedWedge(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      } else {
        svgWrapper.drawLine(
          new Line(a, b, elementA, elementB, isChiralCenterA, isChiralCenterB)
        );
      }
    }
    if (debug) {
      const midpoint = Vector2.midpoint(a, b);
      svgWrapper.drawDebugText(midpoint.x, midpoint.y, "e: " + edgeId);
    }
  }
  /**
   * Draw the highlights for atoms to the canvas.
   *
   * @param {Boolean} debug
   */
  drawAtomHighlights(debug) {
    const preprocessor = this.preprocessor;
    const opts = preprocessor.opts;
    const graph = preprocessor.graph;
    const rings = preprocessor.rings;
    const svgWrapper = this.svgWrapper;
    for (let i = 0; i < graph.vertices.length; i++) {
      const vertex = graph.vertices[i];
      const atom = vertex.value;
      for (let j = 0; j < preprocessor.highlight_atoms.length; j++) {
        const highlight = preprocessor.highlight_atoms[j];
        if (atom.class === highlight[0]) {
          svgWrapper.drawAtomHighlight(
            vertex.position.x,
            vertex.position.y,
            highlight[1]
          );
        }
      }
    }
  }
  /**
   * Draws the vertices representing atoms to the canvas.
   *
   * @param {Boolean} debug A boolean indicating whether or not to draw debug messages to the canvas.
   */
  drawVertices(debug) {
    const preprocessor = this.preprocessor, opts = preprocessor.opts, graph = preprocessor.graph, rings = preprocessor.rings, svgWrapper = this.svgWrapper;
    let i = graph.vertices.length;
    for (let i2 = 0; i2 < graph.vertices.length; i2++) {
      const vertex = graph.vertices[i2];
      const atom = vertex.value;
      let charge = 0;
      let isotope = 0;
      const bondCount = vertex.value.bondCount;
      const element = atom.element;
      let hydrogens = Atom.maxBonds[element] - bondCount;
      let dir = vertex.getTextDirection(graph.vertices);
      const isTerminal = opts.terminalCarbons || element !== "C" || atom.hasAttachedPseudoElements ? vertex.isTerminal() : false;
      const isCarbon = atom.element === "C";
      if (atom.element === "N" && atom.isPartOfAromaticRing) {
        hydrogens = 0;
      }
      if (atom.bracket) {
        hydrogens = atom.bracket.hcount;
        charge = atom.bracket.charge;
        isotope = atom.bracket.isotope;
      }
      if (opts.atomVisualization === "allballs") {
        svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);
      } else if (atom.isDrawn && (!isCarbon || atom.drawExplicit || isTerminal || atom.hasAttachedPseudoElements) || graph.vertices.length === 1) {
        if (opts.atomVisualization === "default") {
          const attachedPseudoElements = atom.getAttachedPseudoElements();
          if (atom.hasAttachedPseudoElements && graph.vertices.length === Object.keys(attachedPseudoElements).length + 1) {
            dir = "right";
          }
          svgWrapper.drawText(
            vertex.position.x,
            vertex.position.y,
            element,
            hydrogens,
            dir,
            isTerminal,
            charge,
            isotope,
            graph.vertices.length,
            attachedPseudoElements
          );
        } else if (opts.atomVisualization === "balls") {
          svgWrapper.drawBall(vertex.position.x, vertex.position.y, element);
        }
      } else if (vertex.getNeighbourCount() === 2 && vertex.forcePositioned === true) {
        const a = graph.vertices[vertex.neighbours[0]].position;
        const b = graph.vertices[vertex.neighbours[1]].position;
        const angle = Vector2.threePointangle(vertex.position, a, b);
        if (Math.abs(Math.PI - angle) < 0.1) {
          svgWrapper.drawPoint(vertex.position.x, vertex.position.y, element);
        }
      }
      if (debug) {
        const value = "v: " + vertex.id + " " + ArrayHelper.print(atom.ringbonds);
        svgWrapper.drawDebugText(vertex.position.x, vertex.position.y, value);
      }
    }
    if (opts.debug) {
      for (let i2 = 0; i2 < rings.length; i2++) {
        const center = rings[i2].center;
        svgWrapper.drawDebugPoint(center.x, center.y, "r: " + rings[i2].id);
      }
    }
  }
  /**
   * Returns the total overlap score of the current molecule.
   *
   * @returns {Number} The overlap score.
   */
  getTotalOverlapScore() {
    return this.preprocessor.getTotalOverlapScore();
  }
  /**
   * Returns the molecular formula of the loaded molecule as a string.
   *
   * @returns {String} The molecular formula.
   */
  getMolecularFormula(graph = null) {
    return this.preprocessor.getMolecularFormula(graph);
  }
  /**
   * @param {Array} normals list of normals to multiply
   * @param {Number} spacing value to multiply normals by
   */
  multiplyNormals(normals, spacing) {
    normals[0].multiplyScalar(spacing);
    normals[1].multiplyScalar(spacing);
  }
};

// src/Drawer.ts
var Drawer = class {
  svgDrawer;
  /**
   * The constructor for the class SmilesDrawer.
   *
   * @param {Object} options An object containing custom values for different options. It is merged with the default options.
   */
  constructor(options) {
    this.svgDrawer = new SvgDrawer(options);
  }
  /**
   * Draws the parsed smiles data to a canvas element.
   *
   * @param {Object} data The tree returned by the smiles parser.
   * @param {(String|HTMLCanvasElement)} target The id of the HTML canvas element the structure is drawn to - or the element itself.
   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
   */
  draw(data, target, themeName = "light", infoOnly = false, highlight_atoms = []) {
    let canvas = null;
    if (typeof target === "string") {
      canvas = document.getElementById(target);
    } else {
      canvas = target;
    }
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttributeNS(
      null,
      "viewBox",
      "0 0 " + this.svgDrawer.opts.width + " " + this.svgDrawer.opts.height
    );
    svg.setAttributeNS(null, "width", this.svgDrawer.opts.width + "");
    svg.setAttributeNS(null, "height", this.svgDrawer.opts.height + "");
    this.svgDrawer.draw(data, svg, themeName, infoOnly, highlight_atoms);
    this.svgDrawer.svgWrapper.toCanvas(
      canvas,
      this.svgDrawer.opts.width,
      this.svgDrawer.opts.height
    );
  }
  /**
   * Returns the total overlap score of the current molecule.
   *
   * @returns {Number} The overlap score.
   */
  getTotalOverlapScore() {
    return this.svgDrawer.getTotalOverlapScore();
  }
  /**
   * Returns the molecular formula of the loaded molecule as a string.
   *
   * @returns {String} The molecular formula.
   */
  getMolecularFormula() {
    this.svgDrawer.getMolecularFormula();
  }
};

// src/Parser.ts
var Parser_default = function() {
  "use strict";
  function peg$subclass(child, parent) {
    function ctor() {
      this.constructor = child;
    }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }
  function peg$SyntaxError(message, expected, found, location) {
    this.message = message;
    this.expected = expected;
    this.found = found;
    this.location = location;
    this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }
  peg$subclass(peg$SyntaxError, Error);
  peg$SyntaxError.buildMessage = function(expected, found) {
    const DESCRIBE_EXPECTATION_FNS = {
      literal: function(expectation) {
        return '"' + literalEscape(expectation.text) + '"';
      },
      class: function(expectation) {
        let escapedParts = "", i;
        for (i = 0; i < expectation.parts.length; i++) {
          escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);
        }
        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
      },
      any: function(expectation) {
        return "any character";
      },
      end: function(expectation) {
        return "end of input";
      },
      other: function(expectation) {
        return expectation.description;
      }
    };
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s) {
      return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected2) {
      let descriptions = new Array(expected2.length), i, j;
      for (i = 0; i < expected2.length; i++) {
        descriptions[i] = describeExpectation(expected2[i]);
      }
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found2) {
      return found2 ? '"' + literalEscape(found2) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};
    const nOpenParentheses = input.split("(").length - 1;
    const nCloseParentheses = input.split(")").length - 1;
    if (nOpenParentheses !== nCloseParentheses) {
      throw peg$buildSimpleError(
        "The number of opening parentheses does not match the number of closing parentheses.",
        0
      );
    }
    let peg$FAILED = {}, peg$startRuleFunctions = {
      chain: peg$parsechain
    }, peg$startRuleFunction = peg$parsechain, peg$c0 = function(s) {
      const branches = [];
      const rings = [];
      for (var i = 0; i < s[1].length; i++) {
        branches.push(s[1][i]);
      }
      for (var i = 0; i < s[2].length; i++) {
        const bond = s[2][i][0] ? s[2][i][0] : "-";
        rings.push({
          bond,
          id: s[2][i][1]
        });
      }
      for (var i = 0; i < s[3].length; i++) {
        branches.push(s[3][i]);
      }
      for (var i = 0; i < s[6].length; i++) {
        branches.push(s[6][i]);
      }
      return {
        atom: s[0],
        isBracket: s[0].element ? true : false,
        branches,
        branchCount: branches.length,
        ringbonds: rings,
        ringbondCount: rings.length,
        bond: s[4] ? s[4] : "-",
        next: s[5],
        hasNext: s[5] ? true : false
      };
    }, peg$c1 = "(", peg$c2 = peg$literalExpectation("(", false), peg$c3 = ")", peg$c4 = peg$literalExpectation(")", false), peg$c5 = function(b) {
      const bond = b[1] ? b[1] : "-";
      b[2].branchBond = bond;
      return b[2];
    }, peg$c6 = function(a) {
      return a;
    }, peg$c7 = /^[\-=#$:\/\\.]/, peg$c8 = peg$classExpectation(
      ["-", "=", "#", "$", ":", "/", "\\", "."],
      false,
      false
    ), peg$c9 = function(b) {
      return b;
    }, peg$c10 = "[", peg$c11 = peg$literalExpectation("[", false), peg$c12 = "se", peg$c13 = peg$literalExpectation("se", false), peg$c14 = "as", peg$c15 = peg$literalExpectation("as", false), peg$c16 = "]", peg$c17 = peg$literalExpectation("]", false), peg$c18 = function(b) {
      return {
        isotope: b[1],
        element: b[2],
        chirality: b[3],
        hcount: b[4],
        charge: b[5],
        class: b[6]
      };
    }, peg$c19 = "B", peg$c20 = peg$literalExpectation("B", false), peg$c21 = "r", peg$c22 = peg$literalExpectation("r", false), peg$c23 = "C", peg$c24 = peg$literalExpectation("C", false), peg$c25 = "l", peg$c26 = peg$literalExpectation("l", false), peg$c27 = /^[NOPSFI]/, peg$c28 = peg$classExpectation(
      ["N", "O", "P", "S", "F", "I"],
      false,
      false
    ), peg$c29 = function(o) {
      if (o.length > 1) {
        return o.join("");
      }
      return o;
    }, peg$c30 = /^[bcnops]/, peg$c31 = peg$classExpectation(
      ["b", "c", "n", "o", "p", "s"],
      false,
      false
    ), peg$c32 = "*", peg$c33 = peg$literalExpectation("*", false), peg$c34 = function(w) {
      return w;
    }, peg$c35 = /^[A-Z]/, peg$c36 = peg$classExpectation([["A", "Z"]], false, false), peg$c37 = /^[a-z]/, peg$c38 = peg$classExpectation([["a", "z"]], false, false), peg$c39 = function(e) {
      return e.join("");
    }, peg$c40 = "%", peg$c41 = peg$literalExpectation("%", false), peg$c42 = /^[1-9]/, peg$c43 = peg$classExpectation([["1", "9"]], false, false), peg$c44 = /^[0-9]/, peg$c45 = peg$classExpectation([["0", "9"]], false, false), peg$c46 = function(r) {
      if (r.length === 1) {
        return Number(r);
      }
      return Number(r.join("").replace("%", ""));
    }, peg$c47 = "@", peg$c48 = peg$literalExpectation("@", false), peg$c49 = "TH", peg$c50 = peg$literalExpectation("TH", false), peg$c51 = /^[12]/, peg$c52 = peg$classExpectation(["1", "2"], false, false), peg$c53 = "AL", peg$c54 = peg$literalExpectation("AL", false), peg$c55 = "SP", peg$c56 = peg$literalExpectation("SP", false), peg$c57 = /^[1-3]/, peg$c58 = peg$classExpectation([["1", "3"]], false, false), peg$c59 = "TB", peg$c60 = peg$literalExpectation("TB", false), peg$c61 = "OH", peg$c62 = peg$literalExpectation("OH", false), peg$c63 = function(c) {
      if (!c[1]) {
        return "@";
      }
      if (c[1] === "@") {
        return "@@";
      }
      return c[1].join("").replace(",", "");
    }, peg$c64 = function(c) {
      return c;
    }, peg$c65 = "+", peg$c66 = peg$literalExpectation("+", false), peg$c67 = function(c) {
      if (!c[1]) {
        return 1;
      }
      if (c[1] !== "+") {
        return Number(c[1].join(""));
      }
      return 2;
    }, peg$c68 = "-", peg$c69 = peg$literalExpectation("-", false), peg$c70 = function(c) {
      if (!c[1]) {
        return -1;
      }
      if (c[1] !== "-") {
        return -Number(c[1].join(""));
      }
      return -2;
    }, peg$c71 = "H", peg$c72 = peg$literalExpectation("H", false), peg$c73 = function(h) {
      if (h[1]) {
        return Number(h[1]);
      }
      return 1;
    }, peg$c74 = ":", peg$c75 = peg$literalExpectation(":", false), peg$c76 = /^[0]/, peg$c77 = peg$classExpectation(["0"], false, false), peg$c78 = function(c) {
      return Number(c[1][0] + c[1][1].join(""));
    }, peg$c79 = function(i) {
      return Number(i.join(""));
    }, peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [
      {
        line: 1,
        column: 1
      }
    ], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error(
          `Can't start parsing from rule "` + options.startRule + '".'
        );
      }
      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }
    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location2) {
      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location2
      );
    }
    function error(message, location2) {
      location2 = location2 !== void 0 ? location2 : peg$computeLocation(peg$savedPos, peg$currPos);
      throw peg$buildSimpleError(message, location2);
    }
    function peg$literalExpectation(text2, ignoreCase) {
      return {
        type: "literal",
        text: text2,
        ignoreCase
      };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
      return {
        type: "class",
        parts,
        inverted,
        ignoreCase
      };
    }
    function peg$anyExpectation() {
      return {
        type: "any"
      };
    }
    function peg$endExpectation() {
      return {
        type: "end"
      };
    }
    function peg$otherExpectation(description) {
      return {
        type: "other",
        description
      };
    }
    function peg$computePosDetails(pos) {
      let details = peg$posDetailsCache[pos], p;
      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }
        details = peg$posDetailsCache[p];
        details = {
          line: details.line,
          column: details.column
        };
        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }
          p++;
        }
        peg$posDetailsCache[pos] = details;
        return details;
      }
    }
    function peg$computeLocation(startPos, endPos) {
      const startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
      return {
        start: {
          offset: startPos,
          line: startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line: endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }
    function peg$fail(expected2) {
      if (peg$currPos < peg$maxFailPos) {
        return;
      }
      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }
      peg$maxFailExpected.push(expected2);
    }
    function peg$buildSimpleError(message, location2) {
      return new peg$SyntaxError(message, null, null, location2);
    }
    function peg$buildStructuredError(expected2, found, location2) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected2, found),
        expected2,
        found,
        location2
      );
    }
    function peg$parsechain() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseatom();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsebranch();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsebranch();
        }
        if (s3 !== peg$FAILED) {
          s4 = [];
          s5 = peg$currPos;
          s6 = peg$parsebond();
          if (s6 === peg$FAILED) {
            s6 = null;
          }
          if (s6 !== peg$FAILED) {
            s7 = peg$parsering();
            if (s7 !== peg$FAILED) {
              s6 = [s6, s7];
              s5 = s6;
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          } else {
            peg$currPos = s5;
            s5 = peg$FAILED;
          }
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            s5 = peg$currPos;
            s6 = peg$parsebond();
            if (s6 === peg$FAILED) {
              s6 = null;
            }
            if (s6 !== peg$FAILED) {
              s7 = peg$parsering();
              if (s7 !== peg$FAILED) {
                s6 = [s6, s7];
                s5 = s6;
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = [];
            s6 = peg$parsebranch();
            while (s6 !== peg$FAILED) {
              s5.push(s6);
              s6 = peg$parsebranch();
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsebond();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsechain();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = [];
                  s9 = peg$parsebranch();
                  while (s9 !== peg$FAILED) {
                    s8.push(s9);
                    s9 = peg$parsebranch();
                  }
                  if (s8 !== peg$FAILED) {
                    s2 = [s2, s3, s4, s5, s6, s7, s8];
                    s1 = s2;
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c0(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsebranch() {
      let s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s2 = peg$c1;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c2);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsebond();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsechain();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s5 = peg$c3;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
            if (s5 !== peg$FAILED) {
              s2 = [s2, s3, s4, s5];
              s1 = s2;
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c5(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseatom() {
      let s0, s1;
      s0 = peg$currPos;
      s1 = peg$parseorganicsymbol();
      if (s1 === peg$FAILED) {
        s1 = peg$parsearomaticsymbol();
        if (s1 === peg$FAILED) {
          s1 = peg$parsebracketatom();
          if (s1 === peg$FAILED) {
            s1 = peg$parsewildcard();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsebond() {
      let s0, s1;
      s0 = peg$currPos;
      if (peg$c7.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        if (s1 === input.charAt(peg$currPos + 1)) {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            throw peg$buildSimpleError(
              "The parser encountered a bond repetition.",
              peg$currPos + 1
            );
          }
        }
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c8);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c9(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsebracketatom() {
      let s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s2 = peg$c10;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c11);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parseisotope();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c12) {
            s4 = peg$c12;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c13);
            }
          }
          if (s4 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c14) {
              s4 = peg$c14;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c15);
              }
            }
            if (s4 === peg$FAILED) {
              s4 = peg$parsearomaticsymbol();
              if (s4 === peg$FAILED) {
                s4 = peg$parseelementsymbol();
                if (s4 === peg$FAILED) {
                  s4 = peg$parsewildcard();
                }
              }
            }
          }
          if (s4 !== peg$FAILED) {
            s5 = peg$parsechiral();
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsehcount();
              if (s6 === peg$FAILED) {
                s6 = null;
              }
              if (s6 !== peg$FAILED) {
                s7 = peg$parsecharge();
                if (s7 === peg$FAILED) {
                  s7 = null;
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parseclass();
                  if (s8 === peg$FAILED) {
                    s8 = null;
                  }
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s9 = peg$c16;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c17);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s2 = [s2, s3, s4, s5, s6, s7, s8, s9];
                      s1 = s2;
                    } else {
                      peg$currPos = s1;
                      s1 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c18(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseorganicsymbol() {
      let s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 66) {
        s2 = peg$c19;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c20);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 114) {
          s3 = peg$c21;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c22);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 67) {
          s2 = peg$c23;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c24);
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 108) {
            s3 = peg$c25;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c26);
            }
          }
          if (s3 === peg$FAILED) {
            s3 = null;
          }
          if (s3 !== peg$FAILED) {
            s2 = [s2, s3];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
        if (s1 === peg$FAILED) {
          if (peg$c27.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c28);
            }
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c29(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsearomaticsymbol() {
      let s0, s1;
      s0 = peg$currPos;
      if (peg$c30.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c31);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c6(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsewildcard() {
      let s0, s1;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c32;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c33);
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseelementsymbol() {
      let s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c35.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c36);
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c37.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c38);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c39(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsering() {
      let s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 37) {
        s2 = peg$c40;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c41);
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c42.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s3 !== peg$FAILED) {
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 === peg$FAILED) {
        if (peg$c44.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c46(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsechiral() {
      let s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 64) {
        s2 = peg$c47;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c48);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 64) {
          s3 = peg$c47;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c48);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c49) {
            s4 = peg$c49;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c50);
            }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c51.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 === peg$FAILED) {
            s3 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c53) {
              s4 = peg$c53;
              peg$currPos += 2;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c54);
              }
            }
            if (s4 !== peg$FAILED) {
              if (peg$c51.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c52);
                }
              }
              if (s5 !== peg$FAILED) {
                s4 = [s4, s5];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
            if (s3 === peg$FAILED) {
              s3 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c55) {
                s4 = peg$c55;
                peg$currPos += 2;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c56);
                }
              }
              if (s4 !== peg$FAILED) {
                if (peg$c57.test(input.charAt(peg$currPos))) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c58);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$FAILED;
              }
              if (s3 === peg$FAILED) {
                s3 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c59) {
                  s4 = peg$c59;
                  peg$currPos += 2;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c60);
                  }
                }
                if (s4 !== peg$FAILED) {
                  if (peg$c42.test(input.charAt(peg$currPos))) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c43);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    if (peg$c44.test(input.charAt(peg$currPos))) {
                      s6 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c45);
                      }
                    }
                    if (s6 === peg$FAILED) {
                      s6 = null;
                    }
                    if (s6 !== peg$FAILED) {
                      s4 = [s4, s5, s6];
                      s3 = s4;
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$FAILED;
                }
                if (s3 === peg$FAILED) {
                  s3 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c61) {
                    s4 = peg$c61;
                    peg$currPos += 2;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c62);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    if (peg$c42.test(input.charAt(peg$currPos))) {
                      s5 = input.charAt(peg$currPos);
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c43);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      if (peg$c44.test(input.charAt(peg$currPos))) {
                        s6 = input.charAt(peg$currPos);
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c45);
                        }
                      }
                      if (s6 === peg$FAILED) {
                        s6 = null;
                      }
                      if (s6 !== peg$FAILED) {
                        s4 = [s4, s5, s6];
                        s3 = s4;
                      } else {
                        peg$currPos = s3;
                        s3 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s3;
                      s3 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s3;
                    s3 = peg$FAILED;
                  }
                }
              }
            }
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c63(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsecharge() {
      let s0, s1;
      s0 = peg$currPos;
      s1 = peg$parseposcharge();
      if (s1 === peg$FAILED) {
        s1 = peg$parsenegcharge();
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c64(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseposcharge() {
      let s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s2 = peg$c65;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c66);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 43) {
          s3 = peg$c65;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c66);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (peg$c42.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c67(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsenegcharge() {
      let s0, s1, s2, s3, s4, s5;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s2 = peg$c68;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c69);
        }
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s3 = peg$c68;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c69);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = peg$currPos;
          if (peg$c42.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c43);
            }
          }
          if (s4 !== peg$FAILED) {
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s5 === peg$FAILED) {
              s5 = null;
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c70(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parsehcount() {
      let s0, s1, s2, s3;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 72) {
        s2 = peg$c71;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c72);
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c44.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c73(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseclass() {
      let s0, s1, s2, s3, s4, s5, s6;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s2 = peg$c74;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c75);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        if (peg$c42.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c43);
          }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c44.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 === peg$FAILED) {
          if (peg$c76.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c77);
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c78(s1);
      }
      s0 = s1;
      return s0;
    }
    function peg$parseisotope() {
      let s0, s1, s2, s3, s4;
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c43);
        }
      }
      if (s2 !== peg$FAILED) {
        if (peg$c44.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c45);
          }
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          if (peg$c44.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c45);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c79(s1);
      }
      s0 = s1;
      return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }
      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }
  return {
    SyntaxError: peg$SyntaxError,
    parse: peg$parse
  };
}();

// src/Reaction.ts
var Reaction = class {
  reactantsSmiles;
  reagentsSmiles;
  productsSmiles;
  reactants;
  reagents;
  products;
  /**
   * The constructor for the class Reaction.
   *
   * @param {string} reactionSmiles A reaction SMILES.
   */
  constructor(reactionSmiles) {
    this.reactantsSmiles = [];
    this.reagentsSmiles = [];
    this.productsSmiles = [];
    this.reactants = [];
    this.reagents = [];
    this.products = [];
    const parts = reactionSmiles.split(">");
    if (parts.length !== 3) {
      throw new Error(
        "Invalid reaction SMILES. Did you add fewer than or more than two '>'?"
      );
    }
    if (parts[0] !== "") {
      this.reactantsSmiles = parts[0].split(".");
    }
    if (parts[1] !== "") {
      this.reagentsSmiles = parts[1].split(".");
    }
    if (parts[2] !== "") {
      this.productsSmiles = parts[2].split(".");
    }
    for (let i = 0; i < this.reactantsSmiles.length; i++) {
      this.reactants.push(Parser_default.parse(this.reactantsSmiles[i]));
    }
    for (let i = 0; i < this.reagentsSmiles.length; i++) {
      this.reagents.push(Parser_default.parse(this.reagentsSmiles[i]));
    }
    for (let i = 0; i < this.productsSmiles.length; i++) {
      this.products.push(Parser_default.parse(this.productsSmiles[i]));
    }
  }
};

// src/ReactionParser.ts
var ReactionParser = class {
  /**
   * Returns the hex code of a color associated with a key from the current theme.
   *
   * @param {String} reactionSmiles A reaction SMILES.
   * @returns {Reaction} A reaction object.
   */
  static parse(reactionSmiles) {
    const reaction = new Reaction(reactionSmiles);
    return reaction;
  }
};

// src/FormulaToCommonName.ts
var formulaToCommonName = {
  C2H4O2: "acetic acid",
  C3H6O: "acetone",
  C2H3N: "acetonitrile",
  C6H6: "benzene",
  CCl4: "carbon tetrachloride",
  C6H5Cl: "chlorobenzene",
  CHCl3: "chloroform",
  C6H12: "cyclohexane",
  C2H4Cl2: "1,2-dichloroethane",
  C4H10O3: "diethylene glycol",
  C6H14O3: "diglyme",
  C4H10O2: "DME",
  C3H7NO: "DMF",
  C2H6OS: "DMSO",
  C2H6O: "ethanol",
  C2H6O2: "ethylene glycol",
  C3H8O3: "glycerin",
  C7H16: "heptane",
  C6H18N3OP: "HMPA",
  C6H18N3P: "HMPT",
  C6H14: "hexane",
  CH4O: "methanol",
  C5H12O: "MTBE",
  CH2Cl2: "methylene chloride",
  CH5H9NO: "NMP",
  CH3NO2: "nitromethane",
  C5H12: "pentane",
  C5H5N: "pyridine",
  C7H8: "toluene",
  C6H15N: "triethyl amine",
  H2O: "water"
};

// src/ReactionDrawer.ts
var ReactionDrawer = class {
  defaultOptions;
  opts;
  drawer;
  molOpts;
  themeManager;
  /**
   * The constructor for the class ReactionDrawer.
   *
   * @param {Object} options An object containing reaction drawing specitic options.
   * @param {Object} moleculeOptions An object containing molecule drawing specific options.
   */
  constructor(options, moleculeOptions) {
    this.defaultOptions = {
      scale: moleculeOptions.scale > 0 ? moleculeOptions.scale : 1,
      fontSize: moleculeOptions.fontSizeLarge * 0.8,
      fontFamily: "Arial, Helvetica, sans-serif",
      spacing: 10,
      plus: {
        size: 9,
        thickness: 1
      },
      arrow: {
        length: moleculeOptions.bondLength * 4,
        headSize: 6,
        thickness: 1,
        margin: 3
      }
    };
    this.opts = Options.extend(true, this.defaultOptions, options);
    this.drawer = new SvgDrawer(moleculeOptions);
    this.molOpts = this.drawer.opts;
  }
  /**
   * Draws the parsed reaction smiles data to a canvas element.
   *
   * @param {Object} reaction The reaction object returned by the reaction smiles parser.
   * @param {(String|SVGElement)} target The id of the HTML canvas element the structure is drawn to - or the element itself.
   * @param {String} themeName='dark' The name of the theme to use. Built-in themes are 'light' and 'dark'.
   * @param {Boolean} infoOnly=false Only output info on the molecule without drawing anything to the canvas.
   *
   * @returns {SVGElement} The svg element
   */
  draw(reaction, target, themeName = "light", textAbove = "{reagents}", textBelow = "", infoOnly = false) {
    this.themeManager = new ThemeManager(this.molOpts.themes, themeName);
    let svg = null;
    if (target === null || target === "svg") {
      svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
      svg.setAttributeNS(null, "width", "500");
      svg.setAttributeNS(null, "height", "500");
    } else if (typeof target === "string") {
      svg = document.getElementById(target);
    } else {
      svg = target;
    }
    while (svg.firstChild) {
      svg.removeChild(svg.firstChild);
    }
    const elements = [];
    let maxHeight = 0;
    for (let i = 0; i < reaction.reactants.length; i++) {
      if (i > 0) {
        elements.push({
          width: this.opts.plus.size * this.opts.scale,
          height: this.opts.plus.size * this.opts.scale,
          svg: this.getPlus()
        });
      }
      const reactantSvg = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      this.drawer.draw(reaction.reactants[i], reactantSvg, themeName, infoOnly);
      const element = {
        width: reactantSvg.viewBox.baseVal.width * this.opts.scale,
        height: reactantSvg.viewBox.baseVal.height * this.opts.scale,
        svg: reactantSvg
      };
      elements.push(element);
      if (element.height > maxHeight) {
        maxHeight = element.height;
      }
    }
    elements.push({
      width: this.opts.arrow.length * this.opts.scale,
      height: this.opts.arrow.headSize * 2 * this.opts.scale,
      svg: this.getArrow()
    });
    let reagentsText = "";
    for (let i = 0; i < reaction.reagents.length; i++) {
      if (i > 0) {
        reagentsText += ", ";
      }
      let text = this.drawer.getMolecularFormula(reaction.reagents[i]);
      if (text in formulaToCommonName) {
        text = formulaToCommonName[text];
      }
      reagentsText += SvgWrapper.replaceNumbersWithSubscript(text);
    }
    textAbove = textAbove.replace("{reagents}", reagentsText);
    const topText = SvgWrapper.writeText(
      textAbove,
      this.themeManager,
      this.opts.fontSize * this.opts.scale,
      this.opts.fontFamily,
      this.opts.arrow.length * this.opts.scale
    );
    let centerOffsetX = (this.opts.arrow.length * this.opts.scale - topText.width) / 2;
    elements.push({
      svg: topText.svg,
      height: topText.height,
      width: this.opts.arrow.length * this.opts.scale,
      offsetX: -(this.opts.arrow.length * this.opts.scale + this.opts.spacing) + centerOffsetX,
      offsetY: -(topText.height / 2) - this.opts.arrow.margin,
      position: "relative"
    });
    const bottomText = SvgWrapper.writeText(
      textBelow,
      this.themeManager,
      this.opts.fontSize * this.opts.scale,
      this.opts.fontFamily,
      this.opts.arrow.length * this.opts.scale
    );
    centerOffsetX = (this.opts.arrow.length * this.opts.scale - bottomText.width) / 2;
    elements.push({
      svg: bottomText.svg,
      height: bottomText.height,
      width: this.opts.arrow.length * this.opts.scale,
      offsetX: -(this.opts.arrow.length * this.opts.scale + this.opts.spacing) + centerOffsetX,
      offsetY: bottomText.height / 2 + this.opts.arrow.margin,
      position: "relative"
    });
    for (let i = 0; i < reaction.products.length; i++) {
      if (i > 0) {
        elements.push({
          width: this.opts.plus.size,
          height: this.opts.plus.size,
          svg: this.getPlus()
        });
      }
      const productSvg = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      );
      this.drawer.draw(reaction.products[i], productSvg, themeName, infoOnly);
      const element = {
        width: productSvg.viewBox.baseVal.width * this.opts.scale,
        height: productSvg.viewBox.baseVal.height * this.opts.scale,
        svg: productSvg
      };
      elements.push(element);
      if (element.height > maxHeight) {
        maxHeight = element.height;
      }
    }
    let totalWidth = 0;
    elements.forEach((element) => {
      const offsetX = element.offsetX ?? 0;
      const offsetY = element.offsetY ?? 0;
      element.svg.setAttributeNS(null, "x", Math.round(totalWidth + offsetX));
      element.svg.setAttributeNS(
        null,
        "y",
        Math.round((maxHeight - element.height) / 2 + offsetY)
      );
      element.svg.setAttributeNS(null, "width", Math.round(element.width));
      element.svg.setAttributeNS(null, "height", Math.round(element.height));
      svg.appendChild(element.svg);
      if (element.position !== "relative") {
        totalWidth += Math.round(element.width + this.opts.spacing + offsetX);
      }
    });
    svg.setAttributeNS(null, "viewBox", `0 0 ${totalWidth} ${maxHeight}`);
    svg.style.width = totalWidth + "px";
    svg.style.height = maxHeight + "px";
    return svg;
  }
  getPlus() {
    const s = this.opts.plus.size;
    const w = this.opts.plus.thickness;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const rect_h = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "rect"
    );
    const rect_v = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "rect"
    );
    svg.setAttributeNS(null, "id", "plus");
    rect_h.setAttributeNS(null, "x", String(0));
    rect_h.setAttributeNS(null, "y", String(s / 2 - w / 2));
    rect_h.setAttributeNS(null, "width", s);
    rect_h.setAttributeNS(null, "height", w);
    rect_h.setAttributeNS(null, "fill", this.themeManager.getColor("C"));
    rect_v.setAttributeNS(null, "x", String(s / 2 - w / 2));
    rect_v.setAttributeNS(null, "y", String(0));
    rect_v.setAttributeNS(null, "width", w);
    rect_v.setAttributeNS(null, "height", s);
    rect_v.setAttributeNS(null, "fill", this.themeManager.getColor("C"));
    svg.appendChild(rect_h);
    svg.appendChild(rect_v);
    svg.setAttributeNS(null, "viewBox", `0 0 ${s} ${s}`);
    return svg;
  }
  getArrowhead() {
    const s = this.opts.arrow.headSize;
    const marker = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "marker"
    );
    const polygon = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "polygon"
    );
    marker.setAttributeNS(null, "id", "arrowhead");
    marker.setAttributeNS(null, "viewBox", `0 0 ${s} ${s}`);
    marker.setAttributeNS(null, "markerUnits", "userSpaceOnUse");
    marker.setAttributeNS(null, "markerWidth", s);
    marker.setAttributeNS(null, "markerHeight", s);
    marker.setAttributeNS(null, "refX", String(0));
    marker.setAttributeNS(null, "refY", String(s / 2));
    marker.setAttributeNS(null, "orient", "auto");
    marker.setAttributeNS(null, "fill", this.themeManager.getColor("C"));
    polygon.setAttributeNS(null, "points", `0 0, ${s} ${s / 2}, 0 ${s}`);
    marker.appendChild(polygon);
    return marker;
  }
  getCDArrowhead() {
    const s = this.opts.arrow.headSize;
    const sw = s * (7 / 4.5);
    const marker = document.createElementNS(
      "http://www.w3.org/2000/svg",
      "marker"
    );
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    marker.setAttributeNS(null, "id", "arrowhead");
    marker.setAttributeNS(null, "viewBox", `0 0 ${sw} ${s}`);
    marker.setAttributeNS(null, "markerUnits", "userSpaceOnUse");
    marker.setAttributeNS(null, "markerWidth", String(sw * 2));
    marker.setAttributeNS(null, "markerHeight", String(s * 2));
    marker.setAttributeNS(null, "refX", String(2.2));
    marker.setAttributeNS(null, "refY", String(2.2));
    marker.setAttributeNS(null, "orient", "auto");
    marker.setAttributeNS(null, "fill", this.themeManager.getColor("C"));
    path.setAttributeNS(null, "style", "fill-rule:nonzero;");
    path.setAttributeNS(
      null,
      "d",
      "m 0 0 l 7 2.25 l -7 2.25 c 0 0 0.735 -1.084 0.735 -2.28 c 0 -1.196 -0.735 -2.22 -0.735 -2.22 z"
    );
    marker.appendChild(path);
    return marker;
  }
  getArrow() {
    const s = this.opts.arrow.headSize;
    const l = this.opts.arrow.length;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    defs.appendChild(this.getCDArrowhead());
    svg.appendChild(defs);
    svg.setAttributeNS(null, "id", "arrow");
    line.setAttributeNS(null, "x1", String(0));
    line.setAttributeNS(null, "y1", String(-this.opts.arrow.thickness / 2));
    line.setAttributeNS(null, "x2", l);
    line.setAttributeNS(null, "y2", String(-this.opts.arrow.thickness / 2));
    line.setAttributeNS(null, "stroke-width", this.opts.arrow.thickness);
    line.setAttributeNS(null, "stroke", this.themeManager.getColor("C"));
    line.setAttributeNS(null, "marker-end", "url(#arrowhead)");
    svg.appendChild(line);
    svg.setAttributeNS(
      null,
      "viewBox",
      `0 ${-s / 2} ${l + s * (7 / 4.5)} ${s}`
    );
    return svg;
  }
};

// src/index.ts
function apply(options, selector = "canvas[data-smiles]", themeName = "light", onError = null) {
  const smilesDrawer = new Drawer(options);
  const elements = document.querySelectorAll(selector);
  for (let i = 0; i < elements.length; i++) {
    const element = elements[i];
    parse(
      element.getAttribute("data-smiles"),
      function(tree) {
        smilesDrawer.draw(tree, element, themeName, false);
      },
      function(err) {
        if (onError) {
          onError(err);
        }
      }
    );
  }
}
function parse(smiles, successCallback, errorCallback) {
  console.log(smiles);
  try {
    if (successCallback) {
      console.log(Parser_default);
      successCallback(Parser_default.parse(smiles));
    }
  } catch (err) {
    if (errorCallback) {
      errorCallback(err);
    }
  }
}
function clean(smiles) {
  return smiles.replace(/[^A-Za-z0-9@\.\+\-\?!\(\)\[\]\{\}/\\=#\$:\*]/g, "");
}
function parseReaction(reactionSmiles, successCallback, errorCallback) {
  try {
    if (successCallback) {
      successCallback(ReactionParser.parse(reactionSmiles));
    }
  } catch (err) {
    if (errorCallback) {
      errorCallback(err);
    }
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ReactionDrawer,
  SvgDrawer,
  apply,
  clean,
  parse,
  parseReaction
});
